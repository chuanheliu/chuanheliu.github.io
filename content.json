{"meta":{"title":"chuanhe的博客","subtitle":"Java影响睡眠","description":null,"author":"Chuanhe Liu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"test","slug":"111","date":"2017-05-08T20:48:04.000Z","updated":"2017-06-05T04:03:09.000Z","comments":true,"path":"2017/05/08/111/","link":"","permalink":"http://yoursite.com/2017/05/08/111/","excerpt":"","text":"this is a test","categories":[],"tags":[]},{"title":"A＊算法剖析","slug":"A＊算法剖析","date":"2017-03-12T21:48:04.000Z","updated":"2017-03-12T00:22:18.000Z","comments":true,"path":"2017/03/12/A＊算法剖析/","link":"","permalink":"http://yoursite.com/2017/03/12/A＊算法剖析/","excerpt":"在网上已经有很多篇关于A星寻路算法的文章，但是大部分都是提供给已经了解基本原理的高级开发者的。 本篇教程将从最基本的原理讲起。我们会一步步讲解A星寻路算法，幷配有很多图解和例子。 不管你使用的是什么编程语言或者操作平台，你会发现本篇教程很有帮助，因为它在非编程语言的层面上解释了算法的原理。","text":"在网上已经有很多篇关于A星寻路算法的文章，但是大部分都是提供给已经了解基本原理的高级开发者的。 本篇教程将从最基本的原理讲起。我们会一步步讲解A星寻路算法，幷配有很多图解和例子。 不管你使用的是什么编程语言或者操作平台，你会发现本篇教程很有帮助，因为它在非编程语言的层面上解释了算法的原理。 现在找下到达一杯咖啡因饮料和美味的零食的最短路径，开始吧！:] &nbsp; 一只探路猫 &nbsp; 让我们想象一下，有一款游戏，游戏中一只猫想要找到获取骨头的路线。 &ldquo;为什么会有一只猫想要骨头？！&rdquo;你可能会这么想。在本游戏中， 这是一只狡猾的猫，他想捡起骨头给狗，以防止被咬死！:] 现在想像一下下图中的猫想找到到达骨头的最短路径： 不幸的是，猫不能直接从它当前的位置走到骨头的位置，因为有面墙挡住了去路，而且它在游戏中不是一只幽灵猫！ 游戏中的猫同样懒惰，它总是想找到最短路径，这样当他回家看望它的女朋友时不会太累:-) 但是我们如何编写一个算法计算出猫要选择的那条路径呢？A星算法拯救了我们！ &nbsp; 简化搜索区域 &nbsp; 寻路的第一步是简化成容易控制的搜索区域。 怎么处理要根据游戏来决定了。例如，我们可以将搜索区域划分成像素点，但是这样的划分粒度对于我们这款基于方块的游戏来说太高了（没必要）。 作为代替，我们使用方块（一个正方形）作为寻路算法的单元。其他的形状类型也是可能的（比如三角形或者六边形），但是正方形是最简单并且最适合我们需求的。 像那样去划分，我们的搜索区域可以简单的用一个地图大小的二维数组去表示。所以如果是2525方块大小的地图，我们的搜索区域将会是一个有625 个正方形的数组。如果我们把地图划分成像素点，搜索区域就是一个有640，000个正方形的数组了（一个方块是3232像素）！ 现在让我们基于目前的区域，把区域划分成多个方块来代表搜索空间（在这个简单的例子中，7*6个方块 = 42 个方块）： &nbsp; Open和Closed列表 &nbsp; 既然我们创建了一个简单的搜索区域，我们来讨论下A星算法的工作原理吧。 除了懒惰之外，我们的猫没有好的记忆力，所以它需要两个列表： 一个记录下所有被考虑来寻找最短路径的方块（称为open 列表）一个记录下不会再被考虑的方块（成为closed列表）猫首先在closed列表中添加当前位置（我们把这个开始点称为点 &ldquo;A&rdquo;）。然后，把所有与它当前位置相邻的可通行小方块添加到open列表中。下图是猫在某一位置时的情景（绿色代表open列表）:现在猫需要判断在这些选项中，哪项才是最短路径，但是它要如何去选择呢？在A星寻路算法中，通过给每一个方块一个和值，该值被称为路径增量。让我们看下它的工作原理！路径增量&nbsp;我们将会给每个方块一个G+H 和值：G是从开始点A到当前方块的移动量。所以从开始点A到相邻小方块的移动量为1，该值会随着离开始点越来越远而增大。H是从当前方块到目标点（我们把它称为点B，代表骨头！）的移动量估算值。这个常被称为探视，因为我们不确定移动量是多少 &ndash; 仅仅是一个估算值。 你也许会对&ldquo;移动量&rdquo;感兴趣。在游戏中，这个概念很简单 &ndash; 仅仅是方块的数量。 然而，在游戏中你可以对这个值做调整。例如： 如果你允许对角线移动，你可以针对对角线移动把移动量调得大一点。如果你有不同的地形，你可以将相应的移动量调整得大一点 &ndash; 例如针对一块沼泽，水，或者猫女海报:-) 这就是大概的意思 &ndash; 现在让我们详细分析下如何计算出G和H值。 关于G值 &nbsp; G是从开始点A到达当前方块的移动量（在本游戏中是指方块的数目）。 为了计算出G的值，我们需要从它的前继（上一个方块）获取，然后加1。所以，每个方块的G值代表了从点A到该方块所形成路径的总移动量。 例如，下图展示了两条到达不同骨头的路径，每个方块都标有它的G值： 关于H值 H值是从当前方块到终点的移动量估算值（在本游戏中是指方块的数目）。 移动量估算值离真实值越接近，最终的路径会更加精确。如果估算值停止作用，很可能生成出来的路径不会是最短的（但是它可能是接近的）。这个题目相对复杂，所以我们不会再本教程中讲解，但是我在教程的末尾提供了一个网络链接，对它做了很好的解释。 为了让它更简单，我们将使用&ldquo;曼哈顿距离方法&rdquo;（也叫&ldquo;曼哈顿长&rdquo;或者&ldquo;城市街区距离&rdquo;），它只是计算出距离点B，剩下的水平和垂直的方块数量，略去了障碍物或者不同陆地类型的数量。 例如，下图展示了使用&ldquo;城市街区距离&rdquo;，从不同的开始点到终点，去估算H的值（黑色字）： A星算法 &nbsp; 既然你知道如何计算每个方块的和值（我们将它称为F，等于G+H), &nbsp;我们来看下A星算法的原理。 猫会重复以下步骤来找到最短路径： 将方块添加到open列表中，该列表有最小的和值。且将这个方块称为S吧。将S从open列表移除，然后添加S到closed列表中。对于与S相邻的每一块可通行的方块T： 如果T在closed列表中：不管它。如果T不在open列表中：添加它然后计算出它的和值。如果T已经在open列表中：当我们使用当前生成的路径到达那里时，检查F 和值是否更小。如果是，更新它的和值和它的前继。 如果你对它的工作原理还有点疑惑，不用担心 &ndash; 我们会用例子一步步介绍它的原理！:] 猫的路径 让我们看下我们的懒猫到达骨头的行程例子。 在下图中，我根据以下内容，列出了公式F = G + H 中的每项值： F（方块的和值）：左上角G（从A点到方块的移动量）：左下角H（从方块到B点的估算移动量): 右下角 同时，箭头指示了到达相应方块的移动方向。 最后，在每一步中，红色方块表示closed列表，绿色方块表示open列表。 好的，我们开始吧！ 第一步 第一步，猫会确定相对于开始位置（点A）的相邻方块，计算出他们的F和值，然后把他们添加到open列表中： 你会看到每个方块都列出了H值（有两个是6，一个是4）。我建议根据&ldquo;城市街区距离&rdquo;去计算方块的相关值，确保你理解了它的原理。 同时注意F值（在左上角）是G（左下角）值和H（右下脚）值的和。第二步 在第二步中，猫选择了F和值最小的方块，把它添加到closed列表中，然后检索它的相邻方块的相关数值。 现在你将看到拥有最小增量的是F值为4的方块。猫尝试添加所有相邻的方块到open列表中（然后计算他们的和值），除了猫自身的方块不能添加以外（因为它已经被添加到了closed列表中）或者它是墙壁方块（因为它不能通行）。 注意被添加到open列表的两个新方块，他们的G值都增加了1，因为他们现在离开始点有2个方块远了。你也许需要再计算下&ldquo;城市街区距离&rdquo;以确保你理解了每个新方块的H值。第三步 再次，我们选择了有最小F和值（5）的方块，继续重复之前的步骤： 现在，只有一个可能的方块被添加到open列表中了，因为已经有一个相邻的方块在close列表中，其他两个是墙壁方块。 第四步 现在我们遇到了一个有趣的情况。正如你之前看到的，有4个方块的F和值都为7 &ndash; 我们要怎么做呢？！ 有几种解决方法可以使用，但是最简单（快速）的方法是一直跟着最近被添加到open列表中的方块。现在继续沿着最近被添加的方块前进。 这次有两个可通过的相邻方块了，我们还是像之前那样计算他们的和值。第五步 接着我们选择了最小和值（7）的方块，继续重复之前的步骤： 我们越来越接近终点了！ 第六步 你现在训练有素了！我打赌你能够猜出下一步是下面这样子了： 我们差不多到终点了，但是这次你看到有两条到达骨头的最短路径提供给我们选择： 在我们的例子中，有两条最短路径： 1-2-3-4-5-61-2-3-4-5-7 It doesn&rsquo;t really matter which of these we choose, it comes down to the actual implementation in code. 选择哪一条其实没关系，现在到了真正用代码实现的时候了。 第七步 让我们从其中一块方块，再重复一遍步骤吧： 啊哈，骨头在open列表中了！第八步 现在目标方块在open列表中了，算法会把它添加到closed列表中： 然后，算法要做的所有事情就是返回，计算出最终的路径！ 一只有远见的猫 在上面的例子中，我们看到当猫在寻找最短路径时，它经常选择更好的方块（那个在它的未来最短路径上的方块）- 好像它是一只有远见的猫！ 但是如果猫是盲目的，并且总是选择第一个添加到它的列表上的方块，会发生什么事情？ 下图展示了所有在寻找过程中会被使用到的方块。你会看到猫在尝试更多的方块，但是它仍然找到了最短路径（不是之前的那条，而是另一条等价的）： 图中的红色方块不代表最短路径，它们只是代表在某个时候被选择为&ldquo;S&rdquo;的方块。 我建议你看着上面的图，并且尝试过一遍步骤。这次无论你看到哪个相邻的方块，都选择&ldquo;最坏&rdquo;的方式去走。你会发现最后还是找到了最短路径！ 所以你可以看到跟随一个&ldquo;错误的&rdquo;方块是没有问题的，你仍然会在多次重复尝试后找到最短路径。 所以在我们的实现中，我们会按照以下的算法添加方块到open列表中： 相邻的方块会返回这些顺序: 上面/左边/下面/右边。当所有的方块都有相同的和值后，方块会被添加到open列表中（所以第一个被添加的方块是第一个被猫挑选的）。 下面是从原路返回的示意图： 最短的路径是从终点开始，一步步返回到起点构成的（例子：在终点我们可以看到箭头指向右边，所以该方块的前继在它的左边）。 总的来说，我们可以用下面的伪代码，合成猫的寻找过程。这是Objective-C写的，但是你可以用任何的语言去实现它： [openList add:originalSquare]; // start by adding the original position to the open listdo { currentSquare = [openList squareWithLowestFScore]; // Get the square with the lowest F score&nbsp; [closedList add:currentSquare]; // add the current square to the closed list [openList remove:currentSquare]; // remove it to the open list&nbsp; if ([closedList contains:destinationSquare]) { // if we added the destination to the closed list, we’ve found a path // PATH FOUND break; // break the loop }&nbsp; adjacentSquares = [currentSquare walkableAdjacentSquares]; // Retrieve all its walkable adjacent squares&nbsp; foreach (aSquare in adjacentSquares) {&nbsp; if ([closedList contains:aSquare]) { // if this adjacent square is already in the closed list ignore it continue; // Go to the next adjacent square }&nbsp; if (![openList contains:aSquare]) { // if its not in the open list&nbsp; // compute its score, set the parent [openList add:aSquare]; // and add it to the open list&nbsp; } else { // if its already in the open list&nbsp; // test if using the current G score make the aSquare F score lower, if yes update the parent because it means its a better path&nbsp; } }&nbsp;} while(![openList isEmpty]); // Continue until there is no more available square in the open list (which means there is no path)","categories":[],"tags":[]},{"title":"编程能力与编程年龄","slug":"编程能力与编程年龄","date":"2017-03-08T21:48:04.000Z","updated":"2017-03-08T21:34:40.000Z","comments":true,"path":"2017/03/08/编程能力与编程年龄/","link":"","permalink":"http://yoursite.com/2017/03/08/编程能力与编程年龄/","excerpt":"原文：http://coolshell.cn/articles/10688.html 今天，我们又来谈这个老话题，因为我看到一篇论文，但是也一定会有很多人都会找出各种理由来论证这篇论文的是错的，无所谓了，我把这篇文章送给那些和我一样准备为技术和编程执着和坚持的人。","text":"原文：http://coolshell.cn/articles/10688.html 今天，我们又来谈这个老话题，因为我看到一篇论文，但是也一定会有很多人都会找出各种理由来论证这篇论文的是错的，无所谓了，我把这篇文章送给那些和我一样准备为技术和编程执着和坚持的人。 论文 首先，我们先来看一篇论文《Is Programming Knowledge Related to Age?》（PDF链接），这篇论文是两个北卡罗莱纳州立大学计算机科学系的两个人Patrick Morrison 和 Emerson Murphy-Hill 对StackOverflow.com上的用户做了相关的数据挖掘得出来的一些数据。（我们知道StackOverflow.com上的数据是公开的，任何人都可以用来分析和统计，所以这篇论文的真实性是有的） 数据采样和清洗条件如下：（数据全量是1694981用户，平均年龄30.3岁） 15-70岁之间的用户（这年龄段的用户被称做“Working age”），当然，有很多用户没有输入年龄，这些用户都被过滤了。用户在2012年内都回答过问题。因为StackOverflow在2012年对问题和答案的质量要求得比以前高了一倍，所以更能反映程序员的真实水平。Reputation声望在2-100K之间。（注：StackOverflow的用户Reputation是得到社会认可的，在面试和招聘中是硬通货币。比大学的学分更有价值）上述的条件一共过滤出84,248名程序员，平均年龄：29.02岁，平均Reputaion在1073.9分。年龄分布图下面我们来看一下他们的年龄分布图：我们可以看到程序员年纪的正态分布（高点在25岁左右，但是中点在29岁左右）能力和年龄分布图然后，计算每个人每个月的Reputation，这样可以找到这个用户的真正的活跃时间，这样便于计算这个程序员的真实能力。（总声望 / 活跃时间），可以得到他平均每个月得来的Reputation。我们来看看程序员的能力和年龄段的分布图：（你可能会大吃一惊）上图中我们可以看到，程序员的能力在从25岁左右开始上升，一直到50岁后才会开始下降。所以说，程序员吃的不是青春饭。只有码农，靠蛮力，用体力而不是用脑力的程序员才是吃青春饭的人。年纪大的人是否跟不上新技术论文的作者分析了Tag，用了最近5年内比较流行的技术Tag，然后用了一套比较严谨的算法来查看那些所谓的“老程序员”是否在新技术上跟上不了，所谓跟不上，也就是这些老的程序员在回答这些新技术上并不活跃。所谓老，就是37岁以上的程序员（就是我现在的年纪）。得到了下表：可以看到，老程序员和年轻的程序员对于一些新技术的学习来说也是差不多的，甚至有些项还超过了年轻的程序员。结论论文的结论是：1）程序员技术能力上升是可以到50岁或60岁的。2）老程序员在获取新技术上的能力并不比年轻的程序员差。我的一些感受最后，我说一说我的一些感受：这些年来的对于外企和国内感受—— 国外牛B的IT公司的工程能力并不见得比国内的要强多少，但是国外那些NB的IT公司的架构和设计能力远远超过国内的公司，最可怕的是，那些有超强架构和设计能力的“老程序员们”还战斗在一线，这些战斗在一线的老鸟的能力绝对超过100个普能的新手。对年轻程序员的感受——国内新一代的程序员们太浮燥了。老实说，对于大多数人来说，如果你没有编程到30岁，你还不能成为一个“合格”的程序员。所以，并不是编程编到30岁就玩完了，而是编程编到30岁才刚刚入门。这些不合格的程序，整天BS这个不好，那个不好的，而且喜欢速成，好大喜功。我是一个奔四的人了，编程就像登山一样，越往上爬人越少，所以，在我这个年纪还有想法，对编程还有热情的人不多了，基本上都是转Manager了。其实，什么职位，Title都是虚的，公司没了什么都没了，只有技术才是硬通货。而且，越是这个年纪还在玩编程玩技术的人，其实其经验和能力都是比较强的，都是中坚力量，如果还有其它这个年纪和我一样的人，求交往。","categories":[],"tags":[]},{"title":"Java IO流体系中常用的流分类","slug":"Java IO流体系中常用的流分类","date":"2017-02-13T21:48:04.000Z","updated":"2017-03-30T05:17:48.000Z","comments":true,"path":"2017/02/13/Java IO流体系中常用的流分类/","link":"","permalink":"http://yoursite.com/2017/02/13/Java IO流体系中常用的流分类/","excerpt":"","text":"Java流类图结构： &nbsp; 流的概念和作用 流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。&nbsp; IO流的分类 根据处理数据类型的不同分为：字符流和字节流 根据数据流向不同分为：输入流和输出流 &nbsp;字符流和字节流字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。&nbsp;输入流和输出流对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。 &nbsp;Java IO流对象1.输入字节流InputStreamIO 中输入字节流的继承图可见上图，可以看出：InputStream 是所有的输入字节流的父类，它是一个抽象类。ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。&nbsp;2.输出字节流OutputStreamIO 中输出字节流的继承图可见上图，可以看出：OutputStream 是所有的输出字节流的父类，它是一个抽象类。ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据，ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。&nbsp;3.字节流的输入与输出的对应&nbsp;图中蓝色的为主要的对应部分，红色的部分就是不对应部分。紫色的虚线部分代表这些流一般要搭配使用。从上面的图中可以看出Java IO 中的字节流是极其对称的。&ldquo;存在及合理&rdquo;我们看看这些字节流中不太对称的几个类吧！LineNumberInputStream 主要完成从流中读取数据时，会得到相应的行号，至于什么时候分行、在哪里分行是由改类主动确定的，并不是在原始中有这样一个行号。在输出部分没有对应的部分，我们完全可以自己建立一个LineNumberOutputStream，在最初写入时会有一个基准的行号，以后每次遇到换行时会在下一行添加一个行号，看起来也是可以的。好像更不入流了。PushbackInputStream 的功能是查看最后一个字节，不满意就放入缓冲区。主要用在编译器的语法、词法分析部分。输出部分的BufferedOutputStream 几乎实现相近的功能。StringBufferInputStream 已经被Deprecated，本身就不应该出现在InputStream 部分，主要因为String 应该属于字符流的范围。已经被废弃了，当然输出部分也没有必要需要它了！还允许它存在只是为了保持版本的向下兼容而已。SequenceInputStream 可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。完全可以从IO 包中去除，还完全不影响IO 包的结构，却让其更&ldquo;纯洁&rdquo;――纯洁的Decorator 模式。PrintStream 也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream 写入数据，本身内部实现还是带缓冲的。本质上是对其它流的综合运用的一个工具而已。一样可以踢出IO 包！System.out 和System.out 就是PrintStream 的实例！&nbsp;4.字符输入流Reader在上面的继承关系图中可以看出：Reader 是所有的输入字符流的父类，它是一个抽象类。CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。&nbsp;5.字符输出流Writer在上面的关系图中可以看出：Writer 是所有的输出字符流的父类，它是一个抽象类。CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，BufferedWriter 是一个装饰器为Writer 提供缓冲功能。PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似，后面会有它们的对应图。&nbsp;6.字符流的输入与输出的对应&nbsp;7.字符流与字节流转换转换流的特点：其是字符流和字节流之间的桥梁可对读取到的字节数据经过指定编码转换成字符可对读取到的字符数据经过指定编码转换成字节何时使用转换流？当字节和字符之间有转换动作时；流操作的数据需要编码或解码时。具体的对象体现：InputStreamReader:字节到字符的桥梁OutputStreamWriter:字符到字节的桥梁这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。&nbsp;8.File类File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。 &nbsp;9.RandomAccessFile类该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。 可以用于多线程下载或多个线程同时写数据到文件。&nbsp; &lt;/div&gt;","categories":[],"tags":[]},{"title":"机器学习主流算法分析","slug":"机器学习主流算法分析","date":"2017-01-22T19:05:31.000Z","updated":"2017-03-08T08:44:39.000Z","comments":true,"path":"2017/01/22/机器学习主流算法分析/","link":"","permalink":"http://yoursite.com/2017/01/22/机器学习主流算法分析/","excerpt":"机器学习的算法很多。很多时候困惑人们都是，很多算法是一类算法，而有些算法又是从其他算法中延伸出来的。这里，我们从两个方面来给大家介绍，第一个方面是学习的方式，第二个方面是算法的类似性。","text":"机器学习的算法很多。很多时候困惑人们都是，很多算法是一类算法，而有些算法又是从其他算法中延伸出来的。这里，我们从两个方面来给大家介绍，第一个方面是学习的方式，第二个方面是算法的类似性。根据数据类型的不同，对一个问题的建模有不同的方式。在机器学习或者人工智能领域，人们首先会考虑算法的学习方式。在机器学习领域，有几种主要的学习方式。将算法按照学习方式分类是一个不错的想法，这样可以让人们在建模和算法选择的时候考虑能根据输入数据来选择最合适的算法来获得最好的结果。在监督式学习下，输入数据被称为“训练数据”，每组训练数据有一个明确的标识或结果，如对防垃圾邮件系统中“垃圾邮件”“非垃圾邮件”，对手写数字识别中的“1“，”2“，”3“，”4“等。在建立预测模型的时候，监督式学习建立一个学习过程，将预测结果与“训练数据”的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率。监督式学习的常见应用场景如分类问题和回归问题。常见算法有逻辑回归（Logistic Regression）和反向传递神经网络（Back Propagation Neural Network）在非监督式学习中，数据并不被特别标识，学习模型是为了推断出数据的一些内在结构。常见的应用场景包括关联规则的学习以及聚类等。常见算法包括Apriori算法以及k-Means算法。在此学习方式下，输入数据部分被标识，部分没有被标识，这种学习模型可以用来进行预测，但是模型首先需要学习数据的内在结构以便合理的组织数据来进行预测。应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM.）等。在这种学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见的应用场景包括动态系统以及机器人控制等。常见算法包括Q-Learning以及时间差学习（Temporal difference learning）在企业数据应用的场景下， 人们最常用的可能就是监督式学习和非监督式学习的模型。 在图像识别等领域，由于存在大量的非标识的数据和少量的可标识数据， 目前半监督式学习是一个很热的话题。 而强化学习更多的应用在机器人控制及其他需要进行系统控制的领域。根据算法的功能和形式的类似性，我们可以把算法分类，比如说基于树的算法，基于神经网络的算法等等。当然，机器学习的范围非常庞大，有些算法很难明确归类到某一类。而对于有些分类来说，同一分类的算法可以针对不同类型的问题。这里，我们尽量把常用的算法按照最容易理解的方式进行分类。回归算法是试图采用对误差的衡量来探索变量之间的关系的一类算法。回归算法是统计机器学习的利器。在机器学习领域，人们说起回归，有时候是指一类问题，有时候是指一类算法，这一点常常会使初学者有所困惑。常见的回归算法包括：最小二乘法（Ordinary Least Square），逻辑回归（Logistic Regression），逐步式回归（Stepwise Regression），多元自适应回归样条（Multivariate Adaptive Regression Splines）以及本地散点平滑估计（Locally Estimated Scatterplot Smoothing） 基于实例的算法常常用来对决策问题建立模型，这样的模型常常先选取一批样本数据，然后根据某些近似性把新数据与样本数据进行比较。通过这种方式来寻找最佳的匹配。因此，基于实例的算法常常也被称为“赢家通吃”学习或者“基于记忆的学习”。常见的算法包括 k-Nearest Neighbor(KNN), 学习矢量量化（Learning Vector Quantization， LVQ），以及自组织映射算法（Self-Organizing Map ， SOM） 正则化方法是其他算法（通常是回归算法）的延伸，根据算法的复杂度对算法进行调整。正则化方法通常对简单模型予以奖励而对复杂算法予以惩罚。常见的算法包括：Ridge Regression， Least Absolute Shrinkage and Selection Operator（LASSO），以及弹性网络（Elastic Net）。决策树算法根据数据的属性采用树状结构建立决策模型， 决策树模型常常用来解决分类和回归问题。常见的算法包括：分类及回归树（Classification And Regression Tree， CART）， ID3 (Iterative Dichotomiser 3)， C4.5， Chi-squared Automatic Interaction Detection(CHAID), Decision Stump, 随机森林（Random Forest）， 多元自适应回归样条（MARS）以及梯度推进机（Gradient Boosting Machine， GBM）贝叶斯方法算法是基于贝叶斯定理的一类算法，主要用来解决分类和回归问题。常见算法包括：朴素贝叶斯算法，平均单依赖估计（Averaged One-Dependence Estimators， AODE），以及Bayesian Belief Network（BBN）。 基于核的算法中最著名的莫过于支持向量机（SVM）了。 基于核的算法把输入数据映射到一个高阶的向量空间， 在这些高阶向量空间里， 有些分类或者回归问题能够更容易的解决。 常见的基于核的算法包括：支持向量机（Support Vector Machine， SVM）， 径向基函数（Radial Basis Function ，RBF)， 以及线性判别分析（Linear Discriminate Analysis ，LDA)等 聚类，就像回归一样，有时候人们描述的是一类问题，有时候描述的是一类算法。聚类算法通常按照中心点或者分层的方式对输入数据进行归并。所以的聚类算法都试图找到数据的内在结构，以便按照最大的共同点将数据进行归类。常见的聚类算法包括 k-Means算法以及期望最大化算法（Expectation Maximization， EM）。 关联规则学习通过寻找最能够解释数据变量之间关系的规则，来找出大量多元数据集中有用的关联规则。常见算法包括 Apriori算法和Eclat算法等。 人工神经网络算法模拟生物神经网络，是一类模式匹配算法。通常用于解决分类和回归问题。人工神经网络是机器学习的一个庞大的分支，有几百种不同的算法。（其中深度学习就是其中的一类算法，我们会单独讨论），重要的人工神经网络算法包括：感知器神经网络（Perceptron Neural Network）, 反向传递（Back Propagation）， Hopfield网络，自组织映射（Self-Organizing Map, SOM）。学习矢量量化（Learning Vector Quantization， LVQ） 深度学习算法是对人工神经网络的发展。 在近期赢得了很多关注， 特别是百度也开始发力深度学习后， 更是在国内引起了很多关注。 在计算能力变得日益廉价的今天，深度学习试图建立大得多也复杂得多的神经网络。很多深度学习的算法是半监督式学习算法，用来处理存在少量未标识数据的大数据集。常见的深度学习算法包括：受限波尔兹曼机（Restricted Boltzmann Machine， RBN）， Deep Belief Networks（DBN），卷积网络（Convolutional Network）, 堆栈式自动编码器（Stacked Auto-encoders）。 像聚类算法一样，降低维度算法试图分析数据的内在结构，不过降低维度算法是以非监督学习的方式试图利用较少的信息来归纳或者解释数据。这类算法可以用于高维数据的可视化或者用来简化数据以便监督式学习使用。常见的算法包括：主成份分析（Principle Component Analysis， PCA），偏最小二乘回归（Partial Least Square Regression，PLS）， Sammon映射，多维尺度（Multi-Dimensional Scaling, MDS）, 投影追踪（Projection Pursuit）等。集成算法用一些相对较弱的学习模型独立地就同样的样本进行训练，然后把结果整合起来进行整体预测。集成算法的主要难点在于究竟集成哪些独立的较弱的学习模型以及如何把学习结果整合起来。这是一类非常强大的算法，同时也非常流行。常见的算法包括：Boosting， Bootstrapped Aggregation（Bagging）， AdaBoost，堆叠泛化（Stacked Generalization， Blending），梯度推进机（Gradient Boosting Machine, GBM），随机森林（Random Forest）。","categories":[],"tags":[]},{"title":"深度优先与广度优先","slug":"深度优先与广度优先","date":"2016-12-14T15:16:02.000Z","updated":"2017-03-08T21:43:16.000Z","comments":true,"path":"2016/12/14/深度优先与广度优先/","link":"","permalink":"http://yoursite.com/2016/12/14/深度优先与广度优先/","excerpt":"有两种常用的方法可用来搜索图：即深度优先搜索和广度优先搜索。它们最终都会到达所有连通的顶点。深度优先搜索通过栈来实现，而广度优先搜索通过队列来实现。","text":"有两种常用的方法可用来搜索图：即深度优先搜索和广度优先搜索。它们最终都会到达所有连通的顶点。深度优先搜索通过栈来实现，而广度优先搜索通过队列来实现。 深度优先搜索： 下面图中的数字显示了深度优先搜索顶点被访问的顺序。 为了实现深度优先搜索，首先选择一个起始顶点并需要遵守三个规则： (1) 如果可能，访问一个邻接的未访问顶点，标记它，并把它放入栈中。 (2) 当不能执行规则1时，如果栈不空，就从栈中弹出一个顶点。 (3) 如果不能执行规则1和规则2，就完成了整个搜索过程。 广度优先搜索： 在深度优先搜索中，算法表现得好像要尽快地远离起始点似的。相反，在广度优先搜索中，算法好像要尽可能地靠近起始点。它首先访问起始顶点的所有邻接点，然后再访问较远的区域。它是用队列来实现的。 下面图中的数字显示了广度优先搜索顶点被访问的顺序。 实现广度优先搜索，也要遵守三个规则： (1) 访问下一个未来访问的邻接点，这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中。 (2) 如果因为已经没有未访问顶点而不能执行规则1时，那么从队列头取一个顶点，并使其成为当前顶点。 (3) 如果因为队列为空而不能执行规则2，则搜索结束。 下面是一个图类的java代码，dfs()为深度优先搜索算法，bfs()为广度优先搜索算法：//用于实现深度优先搜索的栈类 class StackX{ private final int SIZE=20; private int[] st; private int top; public StackX(){ st=new int[SIZE]; top=-1; } public void push(int j){ st[++top]=j; } public int pop(){ return st[top–]; } public int peek(){ return st[top]; } public boolean isEmpty(){ return top==-1; } } //用于实现广度优先搜索的队列类 class Queue{ private final int SIZE=20; private int[] queArray; private int front; private int rear; public Queue(){ queArray=new int[SIZE]; front=0; rear=-1; } public void insert(int j){ if(rear==SIZE-1) rear=-1; queArray[++rear]=j; } public int remove(){ int temp=queArray[front++]; if(front==SIZE) front=0; return temp; } public boolean isEmpty(){ return ((rear+1==front)||(front+SIZE-1==rear)); } } //顶点类 class Vertex{ public char label; public boolean wasVisited; public Vertex(char lab){ label=lab; wasVisited=false; } } //图类 public class Graph { private final int MAX_VERTS=20; private Vertex vertexList[]; private int adjMat[][]; private int nVerts; private StackX theStack; private Queue theQueue; /* Creates a new instance of Graph / public Graph() { vertexList=new Vertex[MAX_VERTS]; adjMat=new int[MAX_VERTS][MAX_VERTS]; nVerts=0; for (int j = 0; j &lt; MAX_VERTS; j++) { for (int k = 0; k &lt; MAX_VERTS; k++) { adjMat[j][k]=0; } } theStack=new StackX(); theQueue=new Queue(); } //增加一个顶点 public void addVertex(char lab){ vertexList[nVerts++]=new Vertex(lab); } //增加一条边 public void addEdge(int start,int end){ adjMat[start][end]=1; adjMat[end][start]=1; } public void displayVertex(int v){ System.out.print(vertexList[v].label); } //深度优先搜索 public void dfs(){ vertexList[0].wasVisited=true; displayVertex(0); theStack.push(0); while(!theStack.isEmpty()){ int v=getAdjUnvisitedVertex(theStack.peek()); if(v==-1) theStack.pop(); else{ vertexList[v].wasVisited=true; displayVertex(v); theStack.push(v); } } for(int j=0;j vertexList[j].wasVisited=false; } //得到与v顶点邻接且未访问过的顶点标号 public int getAdjUnvisitedVertex(int v){ for (int j = 0; j &lt; nVerts; j++) { if(adjMat[v][j]==1&amp;&amp;vertexList[j].wasVisited==false) return j; } return -1; } //广度优先搜索 public void bfs(){ vertexList[0].wasVisited=true; displayVertex(0); theQueue.insert(0); int v2; while(!theQueue.isEmpty()){ int v1=theQueue.remove(); while((v2=getAdjUnvisitedVertex(v1))!=-1){ vertexList[v2].wasVisited=true; displayVertex(v2); theQueue.insert(v2); } } for (int j = 0; j &lt; nVerts; j++) { vertexList[j].wasVisited=false; } } } ===============================================================一、深度优先搜索 深度优先搜索就是在搜索树的每一层始终先只扩展一个子节点，不断地向纵深前进直到不能再前进（到达叶子节点或受到深度限制）时，才从当前节点返回到上一级节点，沿另一方向又继续前进。这种方法的搜索树是从树根开始一枝一枝逐渐形成的。 深度优先搜索亦称为纵向搜索。由于一个有解的问题树可能含有无穷分枝，深度优先搜索如果误入无穷分枝（即深度无限），则不可能找到目标节点。所以，深度优先搜索策略是不完备的。另外，应用此策略得到的解不一定是最佳解（最短路径）。 二、 重排九宫问题游戏 在一个3乘3的九宫中有1-8的8个数及一个空格随机摆放在其中的格子里。如下面左图所示。现在要求实现这样的问题：将该九宫调整为如下图右图所示的形式。调整规则是：每次只能将与空格（上，下或左，右）相临的一个数字平移到空格中。试编程实现。 | 2 | 8 | 3 | | 1 | 2 | 3 | - | 1 | | 4 | | 8 | | 4 | | 7 | 6 | 5 | | 7 | 6 | 5 | 深度优先搜索的路径示意图： 三、广度优先搜索 在深度优先搜索算法中，是深度越大的结点越先得到扩展。如果在搜索中把算法改为按结点的层次进行搜索， 本层的结点没有搜索处理完时，不能对下层结点进行处理，即深度越小的结点越先得到扩展，也就是说先产生 的结点先得以扩展处理，这种搜索算法称为广度优先搜索法。广度优先搜索路径示意图： 四、航班问题（来自《The Art of Java》) 一位顾客要预定一张从New York到Los Angeles的航班机票，下面是航班线路，请你为顾客找一种购票方案。 下面是用深度优先搜索求解的程序:// Find connections using a depth-first search. import java.util.; import java.io.; // Flight information. class FlightInfo { String from; String to; int distance; boolean skip; // used in backtracking FlightInfo(String f, String t, int d) { from = f; to = t; distance = d; skip = false; } } class Depth { final int MAX = 100; // This array holds the flight information. FlightInfo flights[] = new FlightInfo[MAX]; int numFlights = 0; // number of entries in flight array Stack btStack = new Stack(); // backtrack stack public static void main(String args[]) { String to, from; Depth ob = new Depth(); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); ob.setup(); try { System.out.print(“From? “); from = br.readLine(); System.out.print(“To? “); to = br.readLine(); ob.isflight(from, to); if(ob.btStack.size() != 0) ob.route(to); } catch (IOException exc) { System.out.println(“Error on input.”); } } // Initialize the flight database. void setup() { addFlight(“New York”, “Chicago”, 900); addFlight(“Chicago”, “Denver”, 1000); addFlight(“New York”, “Toronto”, 500); addFlight(“New York”, “Denver”, 1800); addFlight(“Toronto”, “Calgary”, 1700); addFlight(“Toronto”, “Los Angeles”, 2500); addFlight(“Toronto”, “Chicago”, 500); addFlight(“Denver”, “Urbana”, 1000); addFlight(“Denver”, “Houston”, 1000); addFlight(“Houston”, “Los Angeles”, 1500); addFlight(“Denver”, “Los Angeles”, 1000); } // Put flights into the database. void addFlight(String from, String to, int dist) { if(numFlights &lt; MAX) { flights[numFlights] = new FlightInfo(from, to, dist); numFlights++; } else System.out.println(“Flight database full. “); } // Show the route and total distance. void route(String to) { Stack rev = new Stack(); int dist = 0; FlightInfo f; int num = btStack.size(); // Reverse the stack to display route. for(int i=0; i &lt; num; i++) rev.push(btStack.pop()); for(int i=0; i &lt; num; i++) { f = (FlightInfo) rev.pop(); System.out.print(f.from + “ to “); dist += f.distance; } System.out.println(to); System.out.println(“Distance is “ + dist); } / If there is a flight between from and to, return the distance of flight; otherwise, return 0. / int match(String from, String to) { for(int i=numFlights-1; i &gt; -1; i–) { if(flights[i].from.equals(from) &amp;&amp; flights[i].to.equals(to) &amp;&amp; !flights[i].skip) { flights[i].skip = true; // prevent reuse return flights[i].distance; } } return 0; // not found } // Given from, find any connection. FlightInfo find(String from) { for(int i=0; i &lt; numFlights; i++) { if(flights[i].from.equals(from) &amp;&amp; !flights[i].skip) { FlightInfo f = new FlightInfo(flights[i].from, flights[i].to, flights[i].distance); flights[i].skip = true; // prevent reuse return f; } } return null; } // Determine if there is a route between from and to. void isflight(String from, String to) { int dist; FlightInfo f; // See if at destination. dist = match(from, to); if(dist != 0) { btStack.push(new FlightInfo(from, to, dist)); return; } // Try another connection. f = find(from); if(f != null) { btStack.push(new FlightInfo(from, to, f.distance)); isflight(f.to, to); } else if(btStack.size() &gt; 0) { // Backtrack and try another connection. f = (FlightInfo) btStack.pop(); isflight(f.from, f.to); } } } 解释：isflight()方法用递归方法进行深度优先搜索，它先调用match()方法检查航班的数据库，判断在from和to之间有没有航班可达。如果有，则获取目标信息，并将该线路压入栈中，然后返回（找到一个方案）。否则，就调用find()方法查找from与任意其它城市之间的线路，如果找到一条就返回描述该线路的FlightInfo对象，否则返回null。如果存在这样的一条线路，那么就把该线路保存在f中，并将当前航班信息压到栈的顶部，然后递归调用isflight()方法 ,此时保存在f.to中的城市成为新的出发城市.否则就进行回退,弹出栈顶的第一个节点,然后递归调用isflight()方法。该过程将一直持续到找到目标为止。程序运行结果：C:/java&gt;java Depth From? New York To? Los Angeles New York to Chicago to Denver to Los Angeles Distance is 2900C:/java&gt; 深度优先搜索能够找到一个解，同时，对于上面这个特定问题，深度优先搜索没有经过回退，一次就找到了一个解；但如果数据的组织方式不同，寻找解时就有可能进行多次回退。因此这个例子的输出并不具有普遍性。而且，在搜索一个很长，但是其中并没有解的分支的时候，深度优先搜索的性能将会很差，在这种情况下，深度优先搜索不仅在搜索这条路径时浪费时间，而且还在向目标的回退中浪费时间。再看对这个例子使用广度优先搜索的程序：程序运行结果： C:/java&gt;java Breadth From? New York To? Los Angeles New York to Toronto to Los Angeles Distance is 3000// Find connections using a breadth-first search. import java.util.; import java.io.; // Flight information. class FlightInfo { String from; String to; int distance; boolean skip; // used in backtracking FlightInfo(String f, String t, int d) { from = f; to = t; distance = d; skip = false; } } class Breadth { final int MAX = 100; // This array holds the flight information. FlightInfo flights[] = new FlightInfo[MAX]; int numFlights = 0; // number of entries in flight array Stack btStack = new Stack(); // backtrack stack public static void main(String args[]) { String to, from; Breadth ob = new Breadth(); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); ob.setup(); try { System.out.print(“From? “); from = br.readLine(); System.out.print(“To? “); to = br.readLine(); ob.isflight(from, to); if(ob.btStack.size() != 0) ob.route(to); } catch (IOException exc) { System.out.println(“Error on input.”); } } // Initialize the flight database. void setup() { addFlight(“New York”, “Chicago”, 900); addFlight(“Chicago”, “Denver”, 1000); addFlight(“New York”, “Toronto”, 500); addFlight(“New York”, “Denver”, 1800); addFlight(“Toronto”, “Calgary”, 1700); addFlight(“Toronto”, “Los Angeles”, 2500); addFlight(“Toronto”, “Chicago”, 500); addFlight(“Denver”, “Urbana”, 1000); addFlight(“Denver”, “Houston”, 1000); addFlight(“Houston”, “Los Angeles”, 1500); addFlight(“Denver”, “Los Angeles”, 1000); } // Put flights into the database. void addFlight(String from, String to, int dist) { if(numFlights &lt; MAX) { flights[numFlights] = new FlightInfo(from, to, dist); numFlights++; } else System.out.println(“Flight database full. “); } // Show the route and total distance. void route(String to) { Stack rev = new Stack(); int dist = 0; FlightInfo f; int num = btStack.size(); // Reverse the stack to display route. for(int i=0; i &lt; num; i++) rev.push(btStack.pop()); for(int i=0; i &lt; num; i++) { f = (FlightInfo) rev.pop(); System.out.print(f.from + “ to “); dist += f.distance; } System.out.println(to); System.out.println(“Distance is “ + dist); } / If there is a flight between from and to, return the distance of flight; otherwise, return 0. / int match(String from, String to) { for(int i=numFlights-1; i &gt; -1; i–) { if(flights[i].from.equals(from) &amp;&amp; flights[i].to.equals(to) &amp;&amp; !flights[i].skip) { flights[i].skip = true; // prevent reuse return flights[i].distance; } } return 0; // not found } // Given from, find any connection. FlightInfo find(String from) { for(int i=0; i &lt; numFlights; i++) { if(flights[i].from.equals(from) &amp;&amp; !flights[i].skip) { FlightInfo f = new FlightInfo(flights[i].from, flights[i].to, flights[i].distance); flights[i].skip = true; // prevent reuse return f; } } return null; } / Determine if there is a route between from and to using breadth-first search. / void isflight(String from, String to) { int dist, dist2; FlightInfo f; // This stack is needed by the breadth-first search. Stack resetStck = new Stack(); // See if at destination. dist = match(from, to); if(dist != 0) { btStack.push(new FlightInfo(from, to, dist)); return; } / Following is the first part of the breadth-first modification. It checks all connecting flights from a specified node. / while((f = find(from)) != null) { resetStck.push(f); if((dist = match(f.to, to)) != 0) { resetStck.push(f.to); btStack.push(new FlightInfo(from, f.to, f.distance)); btStack.push(new FlightInfo(f.to, to, dist)); return; } } / The following code resets the skip fields set by preceding while loop. This is also part of the breadth-first modifiction. / int i = resetStck.size(); for(; i!=0; i–) resetSkip((FlightInfo) resetStck.pop()); // Try another connection. f = find(from); if(f != null) { btStack.push(new FlightInfo(from, to, f.distance)); isflight(f.to, to); } else if(btStack.size() &gt; 0) { // Backtrack and try another connection. f = (FlightInfo) btStack.pop(); isflight(f.from, f.to); } } // Reset skip field of specified flight. void resetSkip(FlightInfo f) { for(int i=0; i&lt; numFlights; i++) if(flights[i].from.equals(f.from) &amp;&amp; flights[i].to.equals(f.to)) flights[i].skip = false; } }C:/java&gt;它找到了一个合理的解，但这不具有一般性。因为找到的第一条路径取决于信息的物理组织形式。 如果目标在搜索空间中隐藏得不是太深，那么广度优先搜索的性能会很好。","categories":[],"tags":[]},{"title":"String.format()字符串格式化","slug":"String.format()字符串格式化","date":"2016-11-14T21:48:04.000Z","updated":"2017-03-10T18:10:17.000Z","comments":true,"path":"2016/11/14/String.format()字符串格式化/","link":"","permalink":"http://yoursite.com/2016/11/14/String.format()字符串格式化/","excerpt":"在 Java 的 String 类中，可以使用 format() 方法格式化字符串，该方法有两种重载形式： String.format(String format, Object… args) 和 String.format(Locale locale, String format, Object… args)。两者的唯一区别是前者使用本地语言环境，后者使用指定语言环境","text":"在 Java 的 String 类中，可以使用 format() 方法格式化字符串，该方法有两种重载形式： String.format(String format, Object… args) 和 String.format(Locale locale, String format, Object… args)。两者的唯一区别是前者使用本地语言环境，后者使用指定语言环境查看源码可以发现，该方法最终调用 java.util.Formatter 类的 format 方法。 public static String format(String format, Object… args) { return new Formatter().format(format, args).toString();} public static String format(Locale l, String format, Object… args) { return new Formatter(l).format(format, args).toString();} 所以，掌握了 Formatter 的使用，也就掌握了 String.format 的使用，从此 Java 中格式化字符串再无敌手~ 所以我们这里先来讲解 Formatter 的用法。 参考 Java Api 中关于 Formatter 的使用说明，我们可以发现 format 方法的第一个参数是有固定格式的。其格式如下： %[argument_index$][flags][width][.precision]conversion argument_index: 可选，是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 “1$” 引用，第二个参数由 “2$” 引用，依此类推。 flags: 可选，用来控制输出格式 width: 可选，是一个正整数，表示输出的最小长度 precision:可选，用来限定输出的精度 conversion:必须，用来表示如何格式化参数的字符 参考文档，可以发现 Java 其实把格式化划分为两大类：常规类型格式化和时间日期格式化，下面我们就先来介绍一下常规类型的格式化。 补充：Java 中对格式化其实还有根据类型来分类的，但这里为了方便讲述，只简单的依据格式化的参数类型来讲述，如果以后有机会，会开一篇更详细的博客。 常规类型格式化 在开始之前，这里先放一段 Api 中提供的示例代码，你可以带着示例中的问题去看接下来的内容，也可以看完之后回来看示例，你看懂了多少呢？ StringBuilder sb = new StringBuilder();// Send all output to the Appendable object sbFormatter formatter = new Formatter(sb, Locale.US); // Explicit argument indices may be used to re-order output.formatter.format(“%4$2s %3$2s %2$2s %1$2s“, “a”, “b”, “c”, “d”)// -&gt; “ d c b a” // Optional locale as the first argument can be used to get// locale-specific formatting of numbers. The precision and width can be// given to round and align the value.formatter.format(Locale.FRANCE, “e = %+10.4f“, Math.E);// -&gt; “e = +2,7183” // The ‘(‘ numeric flag may be used to format negative numbers with// parentheses rather than a minus sign. Group separators are// automatically inserted.formatter.format(“Amount gained or lost since last statement: $ %(,.2f“, balanceDelta);// -&gt; “Amount gained or lost since last statement: $ (6,217.58)” // Writes a formatted string to System.out.System.out.format(“Local time: %tT“, Calendar.getInstance());// -&gt; “Local time: 13:34:18” // Writes formatted output to System.err.System.err.printf(“Unable to open file ‘%1$s‘: %2$s“, fileName, exception.getMessage());// -&gt; “Unable to open file ‘food’: No such file or directory” Calendar c = new GregorianCalendar(1995, MAY, 23);String s = String.format(“Duke’s Birthday: %1$tb %1$te, %1$tY“, c);// -&gt; s == “Duke’s Birthday: May 23, 1995” conversion 从上述内容可以发现，只有 conversion 这个参数是必选的。 conversion 是用来表示如何格式化参数的字符。先来看个例子： //输出：我的名字叫：小明System.out.println(String.format(“大家好，我叫：%s“,“小明”)); %s 是一个占位符，s 是一个转换符，指明将参数格式化为字符串。值得注意的是，占位符代表的格式化类型必须与参数的类型相兼容，否则运行时会抛出异常，如： java System.out.println(String.format(“大家好，我叫：%d”,”小明”));运行这段代码，就会抛出如下异常： Exception in thread “main” java.util.IllegalFormatConversionException: d != java.lang.String at java.util.Formatter$FormatSpecifier.failConversion(Formatter.java:4302) at java.util.Formatter$FormatSpecifier.printInteger(Formatter.java:2793) at java.util.Formatter$FormatSpecifier.print(Formatter.java:2747) at java.util.Formatter.format(Formatter.java:2520) at java.util.Formatter.format(Formatter.java:2455) at java.lang.String.format(String.java:2940) 那么，转换符除了 s ，还有哪些呢？那我们就来看下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264private static void formatConversion() &#123;&lt;br&gt;System.out.println(String.format(&quot;&apos;b&apos;:将参数格式化为boolean类型输出，&apos;B&apos;的效果相同,但结果中字母为大写。%b&quot;, false));&lt;br&gt;System.out.println(String.format(&quot;&apos;h&apos;:将参数格式化为散列输出，原理：Integer.toHexString(arg.hashCode())，&apos;H&apos;的效果相同,但结果中字母为大写。%h&quot;, &quot;ABC&quot;));&lt;br&gt;System.out.println(String.format(&quot;&apos;s&apos;:将参数格式化为字符串输出，如果参数实现了 Formattable接口，则调用 formatTo方法。&apos;S&apos;的效果相同。%s&quot;, 16));&lt;br&gt;System.out.println(String.format(&quot;FormatImpl类实现了Formattable接口：%s&quot;, new FormatImpl()));&lt;br&gt;System.out.println(String.format(&quot;&apos;c&apos;:将参数格式化为Unicode字符，&apos;C&apos;的效果相同。%c&quot;, &apos;A&apos;));&lt;br&gt;System.out.println(String.format(&quot;&apos;d&apos;:将参数格式化为十进制整数。%d&quot;, 11));&lt;br&gt;System.out.println(String.format(&quot;&apos;o&apos;:将参数格式化为八进制整数。%o&quot;, 9));&lt;br&gt;System.out.println(String.format(&quot;&apos;x&apos;:将参数格式化为十六进制整数。%x&quot;, 17));&lt;br&gt;System.out.println(String.format(&quot;&apos;e&apos;:将参数格式化为科学计数法的浮点数，&apos;E&apos;的效果相同。%E&quot;, 10.000001));&lt;br&gt;System.out.println(String.format(&quot;&apos;f&apos;:将参数格式化为十进制浮点数。%f&quot;, 10.000001));&lt;br&gt;System.out.println(String.format(&quot;&apos;g&apos;:根据具体情况，自动选择用普通表示方式还是科学计数法方式，&apos;G&apos;效果相同。10.01=%g&quot;, 10.01));&lt;br&gt;System.out.println(String.format(&quot;&apos;g&apos;:根据具体情况，自动选择用普通表示方式还是科学计数法方式，&apos;G&apos;效果相同。10.00000000005=%g&quot;, 10.00000000005));&lt;br&gt;System.out.println(String.format(&quot;&apos;a&apos;:结果被格式化为带有效位数和指数的十六进制浮点数，&apos;A&apos;效果相同,但结果中字母为大写。%a&quot;, 10.1));&lt;br&gt;System.out.println(String.format(&quot;&apos;t&apos;:时间日期格式化前缀，会在后面讲述&quot;));&lt;br&gt;System.out.println(String.format(&quot;&apos;%%&apos;:输出%%。%%&quot;));&lt;br&gt;System.out.println(String.format(&quot;&apos;n&apos;平台独立的行分隔符。System.getProperty(&quot;line.separator&quot;)可以取得平台独立的行分隔符，但是用在format中间未免显得过于烦琐了%n已经换行&quot;));&lt;br&gt;&#125;&lt;/p&gt;&lt;p&gt;private static class FormatImpl implements Formattable &#123;&lt;/p&gt;&lt;p&gt;@Override&lt;br&gt;public void formatTo(Formatter formatter, int flags, int width, int precision) &#123;&lt;br&gt;formatter.format(&quot;我是Formattable接口的实现类&quot;);&lt;br&gt;&#125;&lt;br&gt;&#125;&lt;br&gt;```&amp;lt;/p&amp;gt;&lt;p&gt;输出如下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;&apos;b&apos;:将参数格式化为boolean类型输出，&apos;B&apos;的效果相同,但结果中字母为大写。false &apos;h&apos;:将参数格式化为散列输出，原理：Integer.toHexString(arg.hashCode())，&apos;H&apos;的效果相同,但结果中字母为大写。fc42 &apos;s&apos;:将参数格式化为字符串输出，如果参数实现了 Formattable接口，则调用 formatTo方法。&apos;S&apos;的效果相同。16 FormatImpl类实现了Formattable接口：我是Formattable接口的实现类 &apos;c&apos;:将参数格式化为Unicode字符，&apos;C&apos;的效果相同。A &apos;d&apos;:将参数格式化为十进制整数。11 &apos;o&apos;:将参数格式化为八进制整数。11 &apos;x&apos;:将参数格式化为十六进制整数。11 &apos;e&apos;:将参数格式化为科学计数法的浮点数，&apos;E&apos;的效果相同。1.000000E+01 &apos;f&apos;:将参数格式化为十进制浮点数。10.000001 &apos;g&apos;:根据具体情况，自动选择用普通表示方式还是科学计数法方式，&apos;G&apos;效果相同。10.01=10.0100 &apos;g&apos;:根据具体情况，自动选择用普通表示方式还是科学计数法方式，&apos;G&apos;效果相同。10.00000000005=10.0000 &apos;a&apos;:结果被格式化为带有效位数和指数的十六进制浮点数，&apos;A&apos;效果相同,但结果中字母为大写。0x1.4333333333333p3 &apos;t&apos;:时间日期格式化前缀，会在后面讲述 &apos;%&apos;:输出%。% &apos;n&apos;:平台独立的行分隔符。System.getProperty(&quot;line.separator&quot;)可以取得平台独立的行分隔符，但是用在format中间未免显得过于烦琐了 已经换行&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对于浮点转换符 &apos;e&apos; 、&apos;E&apos; 和 &apos;f&apos;，精度是小数点分隔符后的位数。如果转换符是 &apos;g&apos; 或 &apos;G&apos;，那么精度是舍入计算后所得数值的所有位数。如果转换是 &apos;a&apos; 或 &apos;A&apos;，则不必指定精度。&lt;/li&gt;&lt;li&gt;对于部分转换符，如 &apos;b&apos; 和 &apos;B&apos; ，两者转换效果是相似的，但是 &apos;B&apos; 会把输出中的字母都转换为大写，其它相似特性的转换符应该还有好多，大家可以去找一下O(∩_∩)O哈哈~&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;argument_index&quot;&gt;argument_index&lt;/h3&gt;&lt;p&gt;还记得前面那个小明的例子嘛？现在我们来改变一下输出，要求输出如下内容：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//其中，小明、25、小小明都是由参数传递大家好，我叫：小明，今年：25岁。小明是小小明的爸爸。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到这个，大家会怎么做呢？也许，你会写成：&lt;/p&gt;&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;大家好，我叫：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;，今年：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;岁。&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;是&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;的爸爸。&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;小明&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;小明&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;小小明&quot;&lt;/span&gt;));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;恩，这样做输出的确没错，但是我们却重复输入参数“小明”。这里，就要用到 argument_index 这个参数。使用 argument_index 可以指定使用第几个参数来替换占位符，一旦使用 argument_index 用于指出参数在参数列表中位置，则所有占位符都要加上，否则会出错。修改之后的代码如下：&lt;/p&gt;&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;大家好，我叫：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;，今年：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%2$d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;岁。&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;是&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%3$s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;的爸爸。&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;小明&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;小小明&quot;&lt;/span&gt;));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：对于&lt;/p&gt;&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;大家好，我叫：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;，今年：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;岁。&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;是&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;的爸爸。&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;小明&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;小明&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;小小明&quot;&lt;/span&gt;));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 Java 中执行可能没什么问题，但如果把 &lt;code&gt;&quot;大家好，我叫：%s，今年：%d岁。%s是%s的爸爸。&quot;&lt;/code&gt; 放到 Android 的 strings.xml 中，则会出现错误，解决办法就是指明每个参数在参数列表中位置。&lt;/p&gt;&lt;h3 id=&quot;flags&quot;&gt;flags&lt;/h3&gt;&lt;p&gt;flags是可选参数，用于控制输出的格式，比如左对齐、金额用逗号隔开。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&apos;-&apos; 在最小宽度内左对齐，不可以与“用0填充”同时使用&apos;+&apos; 结果总是包括一个符号&apos; &apos; 正值前加空格，负值前加负号&apos;0&apos; 结果将用零来填充&apos;,&apos; 每3位数字之间用“，”分隔(只适用于fgG的转换)&apos;(&apos; 若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(只适用于eEfgG的转换)&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;* flags 的标识&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;formatFlags&lt;/span&gt;() &#123; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;-&apos;:在最小宽度内左对齐，不可与&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;用0填充&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;同时使用。&quot;&lt;/span&gt;); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;设置最小宽度为8为，左对齐。&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%-8d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%-8d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%-8d%n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;99999999&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;0&apos;:结果将用零来填充。设置最小宽度为8，&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;22&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;99999990&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;+&apos;:结果总是包括一个符号。&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%+d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%+d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%+d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos; &apos;:正值前加空格，负值前加负号。&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;% d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;% d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;% d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;,&apos;:每3位数字之间用“，”分隔(只适用于fgG的转换)。&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%,d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%,d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%,d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;(&apos;:若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(只适用于eEfgG的转换)。&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%(d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%(d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&apos;-&apos;:在最小宽度内左对齐，不可与&quot;用0填充&quot;同时使用。设置最小宽度为8为，左对齐。1 :22 :99999999&apos;0&apos;:结果将用零来填充。设置最小宽度为8，00000001:-0000022:99999990&apos;+&apos;:结果总是包括一个符号。+1:-2:+0&apos; &apos;:正值前加空格，负值前加负号。 1:-2: 0&apos;,&apos;:每3位数字之间用“，”分隔(只适用于fgG的转换)。1:100:1,000&apos;(&apos;:若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(只适用于eEfgG的转换)。1:(1)&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;width&quot;&gt;width&lt;/h3&gt;&lt;p&gt;width是可选参数，用于控制输出的宽度。示例如下：&lt;/p&gt;&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;设置最小宽度为8，不满8位用0填充：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%08d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, -&lt;span class=&quot;dv&quot;&gt;10000000&lt;/span&gt;));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;设置最小宽度为8，不满8位用0填充：00000001:-10000000&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是 &lt;strong&gt;width 的值不能为 0&lt;/strong&gt; ，否则会抛出&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Exception in thread &quot;main&quot; java.util.DuplicateFormatFlagsException: Flags = &apos;0&apos; at java.util.Formatter$Flags.parse(Formatter.java:4443) at java.util.Formatter$FormatSpecifier.flags(Formatter.java:2640) at java.util.Formatter$FormatSpecifier.&amp;lt;init&amp;gt;(Formatter.java:2709) at java.util.Formatter.parse(Formatter.java:2560) at java.util.Formatter.format(Formatter.java:2501) at java.util.Formatter.format(Formatter.java:2455) at java.lang.String.format(String.java:2940)&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;precision&quot;&gt;precision&lt;/h3&gt;&lt;p&gt;precision是可选参数，用来限定输出的精度，用于浮点数。示例如下：&lt;/p&gt;&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;* 格式化精度，仅限浮点数&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;formatPrecision&lt;/span&gt;() &#123; &lt;span class=&quot;co&quot;&gt;//System.out.println(String.format(&quot;设置精度为2位：%.2d&quot;, 1));&lt;/span&gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;设置精度为2位：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%.2f&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, 1f));&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;设置精度为2位：1.00&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，如果对整型数据设置精度，则会抛出如下异常：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Exception in thread &quot;main&quot; java.util.IllegalFormatPrecisionException: 2 at java.util.Formatter$FormatSpecifier.checkInteger(Formatter.java:2984) at java.util.Formatter$FormatSpecifier.&amp;lt;init&amp;gt;(Formatter.java:2729) at java.util.Formatter.parse(Formatter.java:2560) at java.util.Formatter.format(Formatter.java:2501) at java.util.Formatter.format(Formatter.java:2455) at java.lang.String.format(String.java:2940)&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;时间日期格式化&quot;&gt;时间日期格式化&lt;/h2&gt;&lt;p&gt;在平时开发中，经常会碰到要显示时间日期的。以前写过一篇 &lt;a href=&quot;http://www.cnblogs.com/travellife/p/3945240.html&quot;&gt;Android 时间、日期相关类和方法&lt;/a&gt; 的博客，里面对 Android 中经常出现的时间日期格式做了总结，但觉得还是过于繁琐，这次总结 Java 中格式化输出，没想到 Java 中已经包含了如此多关于时间的转换符，完全能应对日常开发需要，而且不用复杂的计算。&lt;/p&gt;&lt;p&gt;Java 中时间日期格式化的转换符可以分为三类，分别是：时间格式化转换符、日期格式化转换符、时间日期格式化转换符。相比于日期和时间日期格式化转换符，时间格式化转换符就相对多一点。&lt;/p&gt;&lt;p&gt;时间日期格式化字符串的格式如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;%[argument_index$][flags][width]conversion&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相对于普通的格式，时间日期格式化少了 &lt;strong&gt;precision&lt;/strong&gt; ，而 &lt;strong&gt;conversion&lt;/strong&gt; 是由两个字符组成，且第一个字符固定为 &lt;code&gt;t&lt;/code&gt; 或 &lt;code&gt;T&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;网上部分博文是贴了转换符说明的表格，但是写完代码之后突然发现，Java 格式化输出这部分内容，&lt;strong&gt;看代码和输出其实比看表格更直观，谁让我们是程序员呢？&lt;/strong&gt;下面就用代码来讲述一下时间日期格式化转换符的三种类别。&lt;/p&gt;&lt;h3 id=&quot;格式化时间&quot;&gt;格式化时间&lt;/h3&gt;&lt;p&gt;示例代码如下：&lt;/p&gt;&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;* 格式化时间&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;formatTime&lt;/span&gt;() &#123; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;这是格式化时间相关的，具体输出跟你执行代码时间有关&quot;&lt;/span&gt;); Calendar calendar = Calendar.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;(); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;H&apos;:2位数24小时制，不足两位前面补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tH&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：00-23）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;I&apos;:2位数12小时制，不足两位前面补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tI&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：01-12）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;k&apos;:24小时制，不足两位不补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tk&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：0-23）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;l&apos;:12小时制，不足两位不补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tl&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：1-12）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;M&apos;:2位数的分钟，不足两位前面补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tM&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：00-59）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;S&apos;:分钟中的秒，2位数，不足两位前面补0，60是支持闰秒的一个特殊值：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tS&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：00-60）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;L&apos;:3位数的毫秒，不足三位前面补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tL&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：000-999）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;N&apos;:9位数的微秒，不足九位前面补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tN&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：000000000-999999999）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;p&apos;:输出本地化的上午下午，例如，Locale.US为am或pm，Locale.CHINA为上午或下午&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(Locale.&lt;span class=&quot;fu&quot;&gt;US&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Local.US=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tp&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(Locale.&lt;span class=&quot;fu&quot;&gt;CHINA&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Local.CHINA=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tp&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;z&apos;:时区：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tz&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;Z&apos;:时区缩写字符串：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tZ&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;s&apos;:从1970-1-1 00:00到现在所经历的秒数：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%ts&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;Q&apos;:从1970-1-1 00:00到现在所经历的豪秒数：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tQ&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar));&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;这是格式化时间相关的，具体输出跟你执行代码时间有关&apos;H&apos;:2位数24小时制，不足两位前面补0：21（范围：00-23）&apos;I&apos;:2位数12小时制，不足两位前面补0：09（范围：01-12）&apos;k&apos;:24小时制，不足两位不补0：21（范围：0-23）&apos;l&apos;:12小时制，不足两位不补0：9（范围：1-12）&apos;M&apos;:2位数的分钟，不足两位前面补0：26（范围：00-59）&apos;S&apos;:分钟中的秒，2位数，不足两位前面补0，60是支持闰秒的一个特殊值：44（范围：00-60）&apos;L&apos;:3位数的毫秒，不足三位前面补0：502（范围：000-999）&apos;N&apos;:9位数的微秒，不足九位前面补0：502000000（范围：000000000-999999999）&apos;p&apos;:输出本地化的上午下午，例如，Locale.US为am或pm，Locale.CHINA为上午或下午Local.US=pmLocal.CHINA=下午&apos;z&apos;:时区：+0800&apos;Z&apos;:时区缩写字符串：CST&apos;s&apos;:从1970-1-1 00:00到现在所经历的秒数：1476883604&apos;Q&apos;:从1970-1-1 00:00到现在所经历的豪秒数：1476883604502&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;格式化日期&quot;&gt;格式化日期&lt;/h3&gt;&lt;p&gt;示例代码如下：&lt;/p&gt;&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; * 格式化日期&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;formatDate&lt;/span&gt;() &#123; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-----------------------我是微笑的分割线O(∩_∩)O哈哈~-----------------------------&quot;&lt;/span&gt;); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;这是格式化时间相关的，具体输出跟你执行代码时间有关&quot;&lt;/span&gt;); Calendar calendar = Calendar.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;(); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;B&apos;:本地化显示月份字符串，如：January、February&quot;&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;b&apos;:本地化显示月份字符串的缩写，如：Jan、Feb&quot;&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;h&apos;:本地化显示月份字符串的缩写，效果同&apos;b&apos;&quot;&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(Locale.&lt;span class=&quot;fu&quot;&gt;US&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Locale.US 月份=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$tB&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;，缩写=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$tb&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(Locale.&lt;span class=&quot;fu&quot;&gt;CHINA&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Locale.CHINA 月份=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$tB&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;，缩写=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$tb&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;A&apos;:本地化显示星期几字符串，如：Sunday、Monday&quot;&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;a&apos;:本地化显示星期几字符串的缩写，如：Sun、Mon&quot;&lt;/span&gt;)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(Locale.&lt;span class=&quot;fu&quot;&gt;US&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Locale.US 星期几=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$tA&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;，缩写=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$ta&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(Locale.&lt;span class=&quot;fu&quot;&gt;CHINA&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Locale.CHINA 星期几=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$tA&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;，缩写=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$ta&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;C&apos;:年份除以100的结果，显示两位数，不足两位前面补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tC&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：00-99）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;Y&apos;:显示四位数的年份，格利高里历，即公历。不足四位前面补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tY&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;y&apos;:显示年份的后两位：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%ty&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;（范围：00-99）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;j&apos;:显示当前公历年的天数：第&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tj&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;天（范围：001-366）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;m&apos;:显示当前月份：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tm&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;月（范围：01-13？怎么会有13个月？）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;d&apos;:显示是当前月的第几天，不足两位前面补0：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$tm&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;月第&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$td&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;天（范围：01-31）&quot;&lt;/span&gt;, calendar)); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;e&apos;:显示是当前月的第几天：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$tm&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;月第&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%1$te&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;天（范围：1-31）&quot;&lt;/span&gt;, calendar));&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;-----------------------我是微笑的分割线O(∩_∩)O哈哈~-----------------------------这是格式化时间相关的，具体输出跟你执行代码时间有关&apos;B&apos;:本地化显示月份字符串，如：January、February&apos;b&apos;:本地化显示月份字符串的缩写，如：Jan、Feb&apos;h&apos;:本地化显示月份字符串的缩写，效果同&apos;b&apos;Locale.US 月份=October，缩写=OctLocale.CHINA 月份=十月，缩写=十月&apos;A&apos;:本地化显示星期几字符串，如：Sunday、Monday&apos;a&apos;:本地化显示星期几字符串的缩写，如：Sun、MonLocale.US 星期几=Wednesday，缩写=WedLocale.CHINA 星期几=星期三，缩写=星期三&apos;C&apos;:年份除以100的结果，显示两位数，不足两位前面补0：20（范围：00-99）&apos;Y&apos;:显示四位数的年份，格利高里历，即公历。不足四位前面补0：2016&apos;y&apos;:显示年份的后两位：16（范围：00-99）&apos;j&apos;:显示当前公历年的天数：第293天（范围：001-366）&apos;m&apos;:显示当前月份：10月（范围：01-13？怎么会有13个月？）&apos;d&apos;:显示是当前月的第几天，不足两位前面补0：10月第19天（范围：01-31）&apos;e&apos;:显示是当前月的第几天：10月第19天（范围：1-31）&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：在文档中发现一个略微奇怪的问题，就是 &lt;strong&gt;&lt;code&gt;m&lt;/code&gt;&lt;/strong&gt; 转换符，文档上的大意是：该转换符用于显示当前月是这一年的第几个月，文档里给的范围竟然是01-13，一年怎么会有13个月，告诉我不是我理解错了？&lt;/p&gt;&lt;h3 id=&quot;格式化时间日期&quot;&gt;格式化时间日期&lt;/h3&gt;&lt;p&gt;示例代码如下：&lt;/p&gt;&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; * 格式化时间日期&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;formatTimeAndDate&lt;/span&gt;() &#123; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-----------------------我是微笑的分割线O(∩_∩)O哈哈~-----------------------------&quot;&lt;/span&gt;); System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;这是格式化时间相关的，具体输出跟你执行代码时间有关&quot;&lt;/span&gt;); Calendar calendar = Calendar.&lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;(); &lt;span class=&quot;co&quot;&gt;//%tH:%tM的缩写&lt;/span&gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;R&apos;:将时间格式化为：HH:MM（24小时制）。输出：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tR&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); &lt;span class=&quot;co&quot;&gt;//%tH:%tM:%tS的缩写&lt;/span&gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;T&apos;:将时间格式化为：HH:MM:SS（24小时制）。输出：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tT&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); &lt;span class=&quot;co&quot;&gt;//%tI:%tM:%tS %Tp的缩写，输出形如：&lt;/span&gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;r&apos;:将时间格式化为：09:23:15 下午，跟设置的语言地区有关。输出：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tr&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); &lt;span class=&quot;co&quot;&gt;//%tm/%td/%ty的缩写，输出形如&lt;/span&gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;D&apos;:将时间格式化为：10/19/16。输出：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tD&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); &lt;span class=&quot;co&quot;&gt;//%tY-%tm-%td，输出形如：&lt;/span&gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;F&apos;:将时间格式化为：2016-10-19。输出：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tF&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar)); &lt;span class=&quot;co&quot;&gt;//%ta %tb %td %tT %tZ %tY，输出形如：Sun Jul 20 16:17:00 EDT 1969&lt;/span&gt; System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&apos;c&apos;:将时间格式化为&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Sun Jul 20 16:17:00 EDT 1969&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;。输出：&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%tc&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, calendar));&#125;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;-----------------------我是微笑的分割线O(∩_∩)O哈哈~-----------------------------这是格式化时间相关的，具体输出跟你执行代码时间有关&apos;R&apos;:将时间格式化为：HH:MM（24小时制）。输出：21:26&apos;T&apos;:将时间格式化为：HH:MM:SS（24小时制）。输出：21:26:44&apos;r&apos;:将时间格式化为：09:23:15 下午，跟设置的语言地区有关。输出：09:26:44 下午&apos;D&apos;:将时间格式化为：10/19/16。输出：10/19/16&apos;F&apos;:将时间格式化为：2016-10-19。输出：2016-10-19&apos;c&apos;:将时间格式化为&quot;Sun Jul 20 16:17:00 EDT 1969&quot;。输出：星期三 十月 19 21:26:44 CST 2016&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;系统的介绍了 Java 中格式化字符串的方式及相关的转换符。不过只是对此有印象，方便日后温习，还得在日常中不断加强使用。&lt;/p&gt;&lt;p&gt;虽然 Formatter 中提供了很多关于时间日期的转换符，而且能满足日常的绝大部分使用，但还是存在限制，所以对于有特殊要求的时间格式，还是要学会自己定制。&lt;/p&gt;&lt;p&gt;String.format 这个方法很实用，但如果是大批量进行字符串格式化，就需要考虑到性能方面的问题，因为每次调用 format() 方法都会 new 一个 Formatter 对象。而在 Java 中频繁创建对象需要大量时间，而且还要花时间对这些对象进行垃圾回收和处理。最好的办法就是自己把 DateFormat 、 NumberFormat 、 MessageFormat 这些类封装成静态工具。&lt;/p&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html&quot;&gt;Java Api -- Formatter&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/thc1987/article/details/17528093&quot;&gt;String.format()方法使用说明&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lonely_fireworks/article/details/7962171/&quot;&gt;JAVA字符串格式化-String.format()的使用&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;div id=&quot;MySignature&quot;&gt;&lt;/div&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;div id=&quot;blog_post_info_block&quot;&gt;&lt;div id=&quot;BlogPostCategory&quot;&gt;&lt;/div&gt;&lt;div id=&quot;EntryTag&quot;&gt;&lt;/div&gt;&lt;div id=&quot;blog_post_info&quot;&gt;&lt;/div&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;div id=&quot;post_next_prev&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;","categories":[],"tags":[]},{"title":"浅谈二叉搜索树","slug":"浅谈二叉搜索树","date":"2016-10-07T20:48:04.000Z","updated":"2017-03-08T08:20:45.000Z","comments":true,"path":"2016/10/07/浅谈二叉搜索树/","link":"","permalink":"http://yoursite.com/2016/10/07/浅谈二叉搜索树/","excerpt":"&nbsp; 树的特征和定义 树(Tree)是元素的集合。我们先以比较直观的方式介绍树。下面的数据结构是一个树：","text":"&nbsp; 树的特征和定义 树(Tree)是元素的集合。我们先以比较直观的方式介绍树。下面的数据结构是一个树： 树有多个节点(node)，用以储存元素。某些节点之间存在一定的关系，用连线表示，连线称为边(edge)。边的上端节点称为父节点，下端称为子节点。树像是一个不断分叉的树根。 每个节点可以有多个子节点(children)，而该节点是相应子节点的父节点(parent)。比如说，3,5是6的子节点，6是3,5的父节点；1,8,7是3的子节点, 3是1,8,7的父节点。树有一个没有父节点的节点，称为根节点(root)，如图中的6。没有子节点的节点称为叶节点(leaf)，比如图中的1,8,9,5节点。从图中还可以看到，上面的树总共有4个层次，6位于第一层，9位于第四层。树中节点的最大层次被称为深度。也就是说，该树的深度(depth)为4。 &nbsp; 如果我们从节点3开始向下看，而忽略其它部分。那么我们看到的是一个以节点3为根节点的树： 三角形代表一棵树 再进一步，如果我们定义孤立的一个节点也是一棵树的话，原来的树就可以表示为根节点和子树(subtree)的关系: &nbsp; 上述观察实际上给了我们一种严格的定义树的方法： 1. 树是元素的集合。 2. 该集合可以为空。这时树中没有元素，我们称树为空树 (empty tree)。 3. 如果该集合不为空，那么该集合有一个根节点，以及0个或者多个子树。根节点与它的子树的根节点用一个边(edge)相连。 上面的第三点是以递归的方式来定义树，也就是在定义树的过程中使用了树自身(子树)。由于树的递归特征，许多树相关的操作也可以方便的使用递归实现。我们将在后面看到。 (上述定义来自”Data Structures and Algorithm Analysis in C, by Mark Allen Weiss”。 我觉得有一点不太严格的地方。如果说空树属于树，第三点应该是 &ldquo;…以及0个和多个非空子树…&rdquo; ) &nbsp; 树的实现 树的示意图已经给出了树的一种内存实现方式: 每个节点储存元素和多个指向子节点的指针。然而，子节点数目是不确定的。一个父节点可能有大量的子节点，而另一个父节点可能只有一个子节点，而树的增删节点操作会让子节点的数目发生进一步的变化。这种不确定性就可能带来大量的内存相关操作，并且容易造成内存的浪费。 一种经典的实现方式如下: 树的内存实现 拥有同一父节点的两个节点互为兄弟节点(sibling)。上图的实现方式中，每个节点包含有一个指针指向第一个子节点，并有另一个指针指向它的下一个兄弟节点。这样，我们就可以用统一的、确定的结构来表示每个节点。 &nbsp; 计算机的文件系统是树的结构，比如Linux文件管理背景知识中所介绍的。在UNIX的文件系统中，每个文件(文件夹同样是一种文件)，都可以看做是一个节点。非文件夹的文件被储存在叶节点。文件夹中有指向父节点和子节点的指针(在UNIX中，文件夹还包含一个指向自身的指针，这与我们上面见到的树有所区别)。在git中，也有类似的树状结构，用以表达整个文件系统的版本变化 (参考版本管理三国志)。 文件树 &nbsp; 二叉搜索树的C实现 二叉树(binary)是一种特殊的树。二叉树的每个节点最多只能有2个子节点： 二叉树 由于二叉树的子节点数目确定，所以可以直接采用上图方式在内存中实现。每个节点有一个左子节点(left children)和右子节点(right children)。左子节点是左子树的根节点，右子节点是右子树的根节点。 &nbsp; 如果我们给二叉树加一个额外的条件，就可以得到一种被称作二叉搜索树(binary search tree)的特殊二叉树。二叉搜索树要求：每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大。 (如果我们假设树中没有重复的元素，那么上述要求可以写成：每个节点比它左子树的任意节点大，而且比它右子树的任意节点小) 二叉搜索树，注意树中元素的大小 二叉搜索树可以方便的实现搜索算法。在搜索元素x的时候，我们可以将x和根节点比较: 1. 如果x等于根节点，那么找到x，停止搜索 (终止条件) 2. 如果x小于根节点，那么搜索左子树 3. 如果x大于根节点，那么搜索右子树 二叉搜索树所需要进行的操作次数最多与树的深度相等。n个节点的二叉搜索树的深度最多为n，最少为log(n)。 &nbsp; 下面是用C语言实现的二叉搜索树，并有搜索，插入，删除，寻找最大最小节点的操作。每个节点中存有三个指针，一个指向父节点，一个指向左子节点，一个指向右子节点。 (这样的实现是为了方便。节点可以只保存有指向左右子节点的两个指针，并实现上述操作。) &nbsp; 删除节点相对比较复杂。删除节点后，有时需要进行一定的调整，以恢复二叉搜索树的性质(每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大)。 叶节点可以直接删除。 删除非叶节点时，比如下图中的节点8，我们可以删除左子树中最大的元素(或者右树中最大的元素)，用删除的节点来补充元素8产生的空缺。但该元素可能也不是叶节点，所以它所产生的空缺需要其他元素补充&hellip;&hellip; 直到最后删除一个叶节点。上述过程可以递归实现。 删除节点 删除节点后的二叉搜索树 &nbsp; / By Vamei // binary search tree /#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node position;typedef int ElementTP;struct node { position parent; ElementTP element; position lchild; position rchild;};/ pointer =&gt; root node of the tree /typedef struct node TREE;void print_sorted_tree(TREE);position find_min(TREE);position find_max(TREE);position find_value(TREE, ElementTP);position insert_value(TREE, ElementTP);ElementTP delete_node(position);static int is_root(position);static int is_leaf(position);static ElementTP delete_leaf(position);static void insert_node_to_nonempty_tree(TREE, position);void main(void){ TREE tr; position np; ElementTP element; tr = NULL; tr = insert_value(tr, 18); tr = insert_value(tr, 5); tr = insert_value(tr, 2); tr = insert_value(tr, 8); tr = insert_value(tr, 81); tr = insert_value(tr, 101); printf(“Original:\\n“); print_sorted_tree(tr); np = find_value(tr, 8); if(np != NULL) { delete_node(np); printf(“After deletion:\\n“); print_sorted_tree(tr); }}/ print values of the tree in sorted order / void print_sorted_tree(TREE tr) { if (tr == NULL) return; print_sorted_tree(tr-&gt;lchild); printf(“%d \\n“, tr-&gt;element); print_sorted_tree(tr-&gt;rchild); }/ search for minimum value traverse lchild / position find_min(TREE tr) { position np; np = tr; if (np == NULL) return NULL; while(np-&gt;lchild != NULL) { np = np-&gt;lchild; } return np; }/ search for maximum value traverse rchild / position find_max(TREE tr) { position np; np = tr; if (np == NULL) return NULL; while(np-&gt;rchild != NULL) { np = np-&gt;rchild; } return np; }/ search for value / position find_value(TREE tr, ElementTP value) { if (tr == NULL) return NULL; if (tr-&gt;element == value) { return tr; } else if (value &lt; tr-&gt;element) { return find_value(tr-&gt;lchild, value); } else { return find_value(tr-&gt;rchild, value); } }/ delete node np / ElementTP delete_node(position np) { position replace; ElementTP element; if (is_leaf(np)) { return delete_leaf(np); } else { / if a node is not a leaf, then we need to find a replacement / replace = (np-&gt;lchild != NULL) ? find_max(np-&gt;lchild) : find_min(np-&gt;rchild); element = np-&gt;element; np-&gt;element = delete_node(replace); return element; } }/ insert a value into the tree return root address of the tree / position insert_value(TREE tr, ElementTP value) { position np; / prepare the node / np = (position) malloc(sizeof(struct node)); np-&gt;element = value; np-&gt;parent = NULL; np-&gt;lchild = NULL; np-&gt;rchild = NULL; if (tr == NULL) tr = np; else { insert_node_to_nonempty_tree(tr, np); } return tr; }//=============================================/ np is root? / static int is_root(position np) { return (np-&gt;parent == NULL); }/ np is leaf? / static int is_leaf(position np) { return (np-&gt;lchild == NULL &amp;&amp; np-&gt;rchild == NULL); }/ if an element is a leaf, then it could be removed with no side effect. / static ElementTP delete_leaf(position np) { ElementTP element; position parent; element = np-&gt;element; parent = np-&gt;parent; if(!is_root(np)) { if (parent-&gt;lchild == np) { parent-&gt;lchild = NULL; } else { parent-&gt;rchild = NULL; } } free(np); return element; }/ insert a node to a non-empty tree called by insert_value() / static void insert_node_to_nonempty_tree(TREE tr, position np) { / insert the node / if(np-&gt;element &lt;= tr-&gt;element) { if (tr-&gt;lchild == NULL) { / then tr-&gt;lchild is the proper place / tr-&gt;lchild = np; np-&gt;parent = tr; return; } else { insert_node_to_nonempty_tree(tr-&gt;lchild, np); } } else if(np-&gt;element &gt; tr-&gt;element) { if (tr-&gt;rchild == NULL) { tr-&gt;rchild = np; np-&gt;parent = tr; return; } else { insert_node_to_nonempty_tree(tr-&gt;rchild, np); } } } &nbsp; 运行结果: Original:2 5 8 18 81 101 After deletion:2 5 18 81 101 上述实现中的删除比较复杂。有一种简单的替代操作，称为懒惰删除(lazy deletion)。在懒惰删除时，我们并不真正从二叉搜索树中删除该节点，而是将该节点标记为&ldquo;已删除&rdquo;。这样，我们只用找到元素并标记，就可以完成删除元素了。如果有相同的元素重新插入，我们可以将该节点找到，并取消删除标记。 懒惰删除的实现比较简单，可以尝试一下。树所占据的内存空间不会因为删除节点而减小。懒惰节点实际上是用内存空间换取操作的简便性。 总结 树, 二叉树, 二叉搜索树 二叉搜索树的删除 懒惰删除 ​","categories":[],"tags":[]},{"title":"jar文件到底是什么","slug":"jar文件到底是什么","date":"2016-05-07T20:48:04.000Z","updated":"2017-03-08T20:23:17.000Z","comments":true,"path":"2016/05/07/jar文件到底是什么/","link":"","permalink":"http://yoursite.com/2016/05/07/jar文件到底是什么/","excerpt":"在java中jar文件是一个zip格式的压缩文件，虽然属于zip格式的压缩文件，但是java规范里面对于jar文件还有不少额外的设定，作为一名java开发者，我们应该了解一下。","text":"在java中jar文件是一个zip格式的压缩文件，虽然属于zip格式的压缩文件，但是java规范里面对于jar文件还有不少额外的设定，作为一名java开发者，我们应该了解一下。 1、基本概念我们可以对一个jar文件进行签名，而有的工具或者容器则可以认识或解析我们所设置的签名，从而给这个jar程序赋予相应的权限或者发现代码是否曾被修改过。Package Sealing: 来自同一个package的class文件都必须来自同一个jar文件。这样做的目的是为了保持版本一致性和安全。Package Versioning: jar文件可以包含关于Vendor和Version的信息。 2、META-INF目录这个目录存放的都是一些meta数据。可括如下文件：MANIFEST.MF：最常用的一个文件，定义扩展属性，如版本，类包依赖等。INDEX.LIST：用jar命令-i参数可以生成该文件，用于让ClassLoader可以加快装载class到jvm，估计适合Applet这种需要下载和装载远程的class的场景。xxx.SF: 是本jar文件的签名。xxx.DSA: 跟签名相关。 3、jar文件可以设置为“可执行”文件。jar文件“可执行”的意义在于：（1）在windows里双击该文件可以运行启动应用；设置方法是设置jar文件中的META-INF目录中的MANIFEST.MF文件。加入一行：Main-Class: com.mypackage.MyMainClass 即可也可以采用Ant来设置或者生成这句话。&lt;jar destfile=”myapp.jar” basedir=”classes”&gt;&lt;manifest&gt;&lt;attribute name=”Main-Class” value=”com.mypackage.MyMainClass” /&gt;&lt;/manifest&gt;&lt;/jar&gt;（2）用命令行或者cmd，sh等脚本可以运行启动jar文件。用命令行启动的方式是：java -jar myapplication.jar 4、Package Sealing可以在MANIFEST.MF文件中设定类似如下的内容：Name: com/mypackage/Sealed: true那么，你的package(com.mypackage)的类就必须都来自这同一个jar文件，否则JVM就会抛出异常。 5、jar文件中可以设定对其他jar的依赖关系如果jar的运行需要引用其他jar，那么可以在 MANIFEST.MF中设定或者列出其他的jar。列举时需要列出具体位置和文件名，如果用相对路径，则始于此jar所在的目录起，如果用绝对路径，则在Unix/Linux路径下用/开头，在Windows中似乎得用file:///。然后再接着Windows的路径，如：Class-Path: ./lib/log4j-1.2.11.jar../otherlib/otherfile.jar/share/lib/somefile.jar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;//上面是Unix/Linux绝对路径file:///D:/mydemo/myapp/lib/log4j-1.2.11.jar //上面是Windows绝对路径如果有多个依赖，则用空格或者回车隔开都可以。同样可以用Ant来设置。&lt;attribute name=”Class-Path”&nbsp; value=”./lib/a.jar ./lib/b.jar” /&gt; 6、可以把其他类型的文件（非.class文件）放到jar文件中常规的如.properties文件，.xml文件都是经常放配置信息的，这些文件都可以放到.jar文件中。其实可以放一些图片，音频等，并且同样可以在应用程序中读取到这些文件。当然，不要放太大的文件，以免影响性能。读取这些文件的方法很简单，就是类似MyClass.class.getClassLoader().getResourceAsStream(“/myfiles/myfile.xml”)的写法即可拿到一个InputStream。 7、Package Versioning可以在jar中放入版本信息，如：Name: java/util/Specification-Title: “Java Utility Classes” Specification-Version: “1.2”Specification-Vendor: “Sun Microsystems, Inc.”.Implementation-Title: “java.util” Implementation-Version: “build57”Implementation-Vendor: “Sun Microsystems, Inc.” 8、 引入jar的另外方法a、把jar文件放到JRE的lib/ext目录下，将隐性地能够被你的应用所引用到，即不需要显式出现在CLASSPATH或者你的MANIFEST.MF中；b、Java6开始允许使用通配符来设定CLASSPATH，如java -classpath .\\lib* myapp.jar，这样的话，lib地下的n个jar文件自动加入到CLASSPATH中，而不需要一一列举了。可惜不能在MANIFEST.MF中使用通配符。另外，在J2EE环境下，我们通常部署ear/war，这些部署文件中都有大量的应用代码（.class文件），J2EE没有限制和规定这些.class文件是否一定要打包成.jar文件，如war目录中，可以采用在WEB-INF/classes里面放置大量的.class文件，虽然逻辑上是一样的东西，但是运行态是不同的。如果不打包的话，系统进程（Java服务器，如WebLogic）会需要用多个IO操作来打开程序文件，使用多个文件句柄；如果是打包成.jar的话，则其相关的数量可以大大降低。各自优劣，不言自明。","categories":[],"tags":[]},{"title":"数据库三范式解析","slug":"数据库三范式解析","date":"2016-04-30T20:48:04.000Z","updated":"2017-03-08T21:44:02.000Z","comments":true,"path":"2016/04/30/数据库三范式解析/","link":"","permalink":"http://yoursite.com/2016/04/30/数据库三范式解析/","excerpt":"什么是范式：简言之就是，数据库设计对数据的存储性能，还有开发人员对数据的操作都有莫大的关系。所以建立科学的，规范的的数据库是需要满足一些规范的来优化数据数据存储方式。在关系型数据库中这些规范就可以称为范式。","text":"什么是范式：简言之就是，数据库设计对数据的存储性能，还有开发人员对数据的操作都有莫大的关系。所以建立科学的，规范的的数据库是需要满足一些规范的来优化数据数据存储方式。在关系型数据库中这些规范就可以称为范式。什么是三大范式：第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.注：关系实质上是一张二维表，其中每一行是一个元组，每一列是一个属性理解三大范式第一范式&nbsp; &nbsp;1、每一列属性都是不可再分的属性值，确保每一列的原子性&nbsp;&nbsp; &nbsp;2、两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。&nbsp;&nbsp;&nbsp;如果需求知道那个省那个市并按其分类，那么显然第一个表格是不容易满足需求的，也不符合第一范式。&nbsp;&nbsp;&nbsp;显然第一个表结构不但不能满足足够多物品的要求，还会在物品少时产生冗余。也是不符合第一范式的。&nbsp;第二范式每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。 一个人同时订几个房间，就会出来一个订单号多条数据，这样子联系人都是重复的，就会造成数据冗余。我们应该把他拆开来。 &nbsp;这样便实现啦一条数据做一件事，不掺杂复杂的关系逻辑。同时对表数据的更新维护也更易操作。第三范式&nbsp;数据不能存在传递关系，即没个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c &nbsp;属性之间含有这样的关系，是不符合第三范式的。比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）这样一个表结构，就存在上述关系。 学号–&gt;&nbsp;所在院校 –&gt; (院校地址，院校电话)这样的表结构，我们应该拆开来，如下。（学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）最后：三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求&gt;性能&gt;表结构。所以不能一味的去追求范式建立数据库。","categories":[],"tags":[]},{"title":"深入理解 Java 虚拟机（二）Java内存区域与内存溢出异常(转)","slug":"深入理解-Java-虚拟机（二）Java内存区域与内存溢出异常(转)","date":"2016-04-24T00:48:04.000Z","updated":"2017-03-08T20:35:53.000Z","comments":true,"path":"2016/04/24/深入理解-Java-虚拟机（二）Java内存区域与内存溢出异常(转)/","link":"","permalink":"http://yoursite.com/2016/04/24/深入理解-Java-虚拟机（二）Java内存区域与内存溢出异常(转)/","excerpt":"对于 Java 的开发者来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作去写配对的 delete / free 代码，这样不容易出现内存泄露和内存溢出的问题，只要全权交给虚拟机去处理。不过，也正是因为这样，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会异常艰难。","text":"对于 Java 的开发者来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作去写配对的 delete / free 代码，这样不容易出现内存泄露和内存溢出的问题，只要全权交给虚拟机去处理。不过，也正是因为这样，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会异常艰难。 1.概述 对于 Java 的开发者来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作去写配对的 delete / free 代码，这样不容易出现内存泄露和内存溢出的问题，只要全权交给虚拟机去处理。不过，也正是因为这样，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会异常艰难。 所以我们只有了解了虚拟机的各个区域、各个区域的作用、服务对象等，才能在遇到内存问题时去解决这些问题。 2.运行时数据区域 Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。根据 《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域。 运行时数据区 2.1 - 程序计数器（Program Counter Register） 概述：该区域是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 行号指示器。 作用：通过改变计数器的值来选取下一条需要执行的字节码指令。（分支、循环、跳转、异常处理、线程恢复等）基础功能都依赖与其完成。 特点：1.线程私有：因为 Java 虚拟机的多线程是通过 线程轮流切换 并 分配处理器执行时间 来实现的，在某一时刻，只会执行一条线程。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。2.无内存溢出：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在 执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError 情况的区域。 2.2 - Java 虚拟机栈（Java Virtual Machine Stacks） 2.2.1 - Java 虚拟机栈 概述：描述 Java 方法执行的内存模型，每个方法从调用直至执行的过程，对应着一个 栈帧 在虚拟机栈中入栈到出栈的过程。 作用：存储局部变量表、操作数栈、动态链接、方法出口等信息。 特点：1.线程私有。2.生命周期与线程相同。 2.2.2 - 局部变量表 概述：存放了编译期间可知的各种基本数据类型（8种）、对象引用、returnAddress 类型（指向一条字节码指令的地址）。 占用空间：64位长度的 long 和 double 类型占用 2 个局部变量空间（Slot），其余数据类型只占用 1 个。 分配时机：在编译期间完成分配，当进入一个方法时，这个方法所需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 我们经常将 Java 内存分为堆内存（Heap）和栈内存（Stack），这种分法中所指的栈就是 Java 虚拟机栈，或者说是虚拟机栈中 局部变量表 部分。2.2.3 - 对象引用概述：reference 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。2.2.4 - 异常异常类型发生条件StackOverflowError线程请求的栈深度大于虚拟机所允许的深度时抛出该异常。OutOfMemoryError无法申请到足够的内存时抛出该异常。2.3 - 本地方法栈（Native Method Stack）概述：与虚拟机栈类似，是为虚拟机使用到的 Native 方法服务的内存区域。区别：虚拟机栈：为虚拟机执行 Java 方法（字节码）服务。本地方法栈：为虚拟机使用到的 Native 方法服务。异常：与虚拟机栈一致。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（e.g. Sun HotSpot VM）直接将本地方法栈与虚拟机栈合二为一。2.4 - Java 堆（Java Heap）概述：对于大多数应用来说，该区域是 Java 虚拟机所管理的内存中最大的一块区域。作用：此区域唯一的目的就是存放对象实例。特点：1.被所有线程共享。2.在虚拟机启动时创建。异常异常类型发生条件StackOverflowError无OutOfMemoryError在堆中没有内存来完成实例分配，且堆无法再扩展时，抛出该异常。内存：Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 控制）。Reminde 🤗随着 JIT 编译器的发展与逃逸分析技术成熟，栈上分配、标量替换 等优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也变得不那么绝对了。2.5 - 方法区（Method Area）概述：Java 虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的是与 Java 堆区分开。作用：存储已被虚拟机加载的（类信息、常量、静态变量、即时编译器编译后的代码）等数据。特点：线程共享。异常异常类型发生条件StackOverflowError无OutOfMemoryError当方法区无法满足内存分配需求时，抛出该异常。内存：Java 虚拟机规范对方法区的限制非常宽松，除了和 Java 堆一样不需要连续的内存空间和可以选择固定大小或者可扩展外，可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，这个区域的内存回收目标主要是针对 常量池的回收 和 类型的卸载。2.6 - 运行时常量池（Runtime Constant Pool）概述：方法区的一部分。Class 文件中除了有类的（版本、字段、方法、接口）等描述信息外，还有一项信息就是常量池。作用：用于存放编译器生成的各种 字面量 和 符号引用。动态性：Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法。异常异常类型发生条件StackOverflowError无OutOfMemoryError因为是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时抛出该异常。Java 虚拟机对 Class 文件的每一部分（包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据类型必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现虚拟机可以按照自己的需求来实现这个内存区域。一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在该区域中。2.7 - 直接内存（Direct Memory）概述：并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。作用：在 JDK1.4 中新加入了 NIO（New Input/Output） 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。异常异常类型发生条件StackOverflowError无OutOfMemoryError受到物理内存限制，动态扩展时无法申请到内存时抛出该异常。显然，本机直接内存的分配不会受到 Java 堆大小的限制，但是，既然是内存，肯定还是会受到本机内存（包括 RAM 以及 SWAP 区或者分页大小）大小以及处理器寻址空间的限制，当各个内存区域总和大于物理内存限制（包括物理和操作系统级的限制）时会出现异常。3.HotSpot 虚拟机对象探秘这一部分内容将以 HotSpot 虚拟机和常用的内存区域 Java 堆为例，阐述对象分配、布局和访问的全过程。3.1 - 对象的创建概述：Java 是一门面向对象的编程语言，在 Java 程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个 new 关键字而已，而在虚拟机中对象的创建则分为以下几个步骤。3.1.1 - 类加载概述：虚拟机遇到一条 new 指令时，首先将去检查指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。3.1.2 - 分配内存概述：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式：1.指针碰撞（Bump the Pointer）：假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把哪个指针向空闲那边挪动一段与对象大小相等的距离。2.空闲列表（Free List）：如果 Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。3.1.3 - 同步控制概述：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配地址，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案。方案一：对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试 的方式保证更新操作的原子性。方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 本地线程分配缓冲（Thread Local Allocation Buffer, TLAB） 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 -XX:+/-UseTLAB 参数设定是否使用 TLAB。3.1.4 - 初始化概述：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。作用：保证对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型对应的零值。3.1.5 - 对象头（Object Header）概述：接下来，虚拟机要为对象头数据进行设置。（e.g. 对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄）3.1.6 - init概述：在上面步骤完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，对象的创建才刚刚开始，&lt;init&gt; 方法还没有被执行，所有的字段还为零值。 一般来说，执行 new 指令之后会接着执行 &lt;init&gt; 方法，将对象按照我们的意愿进行初始化，这样一个真正的对象才算完全产生。3.2 - 对象的内存布局在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为以下 3 块区域。3.2.1 - 对象头（Header）HotSpot 虚拟机的对象头包括两部分信息，存储自身的运行时数据的（Mark Word） 和 类型指针。第一部分：Mark Word概述：用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳），这部分数据的长度在 32 位和 64 位的虚拟机中（未开启压缩指针）分别为 32bit 和 64bit。内存：对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 非固定的数据结构 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。HotSpot 虚拟机对象头 Mark Word 表如下 👇存储内容标志位状态对象哈希码、对象分代年龄01未锁定指向锁记录的指针00轻量级锁定指向重量级锁的指针10膨胀（重量级锁定）空（不需要记录信息）11GC 标记偏向线程 ID、偏向时间戳、对象分代年龄01可偏向第二部分：类型指针概述：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。Reminder 👉并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。数组对象：如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。3.2.2 - 实例数据（Instance Data）概述：这部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。存储顺序：这部分的存储顺序会受到虚拟机 分配策略参数（FieldsAllocationStyle） 和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles =&gt; ints =&gt; shorts/chars =&gt; bytes/booleans =&gt; oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true（默认为 true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。3.2.3 - 对齐填充（Padding）概述：不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。原理：由于 HotSpot VM 的自动内存管理系统要求 对象起始地址必须是 8 字节的整倍数，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。3.3 - 对象的访问定位概述：建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以 对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有两种。句柄访问：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示👇。通过句柄访问对象直接指针：Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示👇。通过直接指针访问对象比较：句柄访问：使用句柄访问的最大好处就是 reference 中存储的是 稳定的 句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。指针访问：使用直接访问最大的好处就是 速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。Sun HotSpot 使用的是第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。4.实战：OutOfMemoryError 异常在 Java 虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemory（OOM）异常的可能。目的：1.通过代码验证 Java 虚拟机规范中描述的各个运行时区域的存储内容。2.遇到实际的内存溢出异常时，能根据异常的信息快速判断哪个区域的内存溢出。3.了解什么样的代码可能会导致这些区域内存溢出，并了解如何处理。VM Args 设置Eclipse IDE：Debug Configurations =&gt; Java Application =&gt; YoungGenGC =&gt; Arguments 中的 VM arguments 中进行书写（书写参数以 - 开头，以空格分隔）。控制台：直接跟在 Java 命令之后书写。本人运行在 Mac 系统下，使用 IDEA 进行配置，步骤如下所示👇。虚拟机启动参数.gif1.打开 Run Configurations（￼⌃ + ⌥ + R 选择 0 ）或者￼（⌘ + ⇧ + A 输入 run 选择 run…）。2.点击并打开 VM options。3.写入虚拟机启动参数。4.Apply 并 Run。4.1 - Java 堆溢出概述：Java 堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。测试环境：-verbose:gc-Xms20M // 最小 GC 启动-Xmx20M // 最大 GC 启动-XX:+PrintGCDetails // 打印设置-XX:SurvivorRatio=8 // 存活对象比率测试代码：private static class OOMObject {}public static void main(String[] args) { List&lt;OOMObject&gt; list = new ArrayList&lt;&gt;(); while (true) { list.add(new OOMObject()); }}运行结果：java.lang.OutOfMemoryError: Java heap space分析：Java 堆内存的 OOM 异常是时机应用中常见的内存溢出异常情况。当出现 Java 堆内存溢出时，异常堆栈信息 java.lang.OutOfMemoryError 会跟着进一步提示 Java heap space。解决方式1.堆转储快照：要解决这个区域的异常，一般的手段是先通过内存映像分析工具对 Dump 出来的堆转储快找进行分析，重点是确认内存中的对象是否是必要的，也就是要分清楚到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。2.内存泄露：进一步通过工具查看泄露对象到 CG Roots 的引用链，于是就能找到内存泄露对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息以及 GC Roots 引用链的信息，就可以比较准确地定位出泄露代码的位置。3.内存溢出：如果不存在泄露，换句话说，就是内存中的对象确实都必须还活着，那就应当检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对象看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态过长的情况，尝试减少程序运行期的内存消耗。4.2 - 虚拟机栈和本地方法栈溢出概述：由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 -Xoos 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 -Xss 参数设定。关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常。异常类型发生条件StackOverflowError线程请求的栈深度大于虚拟机所允许的深度时抛出该异常。OutOfMemoryError无法申请到足够的内存时抛出该异常。这里把异常分为两种情况，看似更加严谨，但却存在一些相互重叠的地方：方栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事的两种描述而已。4.2.1 - StackOverflowError测试环境：在此测试中，将测试范围限制于单线程中操作。1.使用 -Xss 参数减少栈内存容量，结果抛出 SOF 异常，异常出现时输出的堆栈深度相应缩小。2.定义了大量的本地变量，增大此方法栈中本地变量表长度。结果抛出 SOF 异常时输出的堆栈深度相应缩小。VM Args: -Xss128k // 栈内存容量测试代码// 记录堆栈深度private int stackLength = 1;public void stackLeak() { stackLength++; stackLeak();}public static void main(String[] args) throws Throwable { JavaVMStackSOF oom = new JavaVMStackSOF(); try { oom.stackLeak(); } catch (Throwable e) { System.out.println(“Stack length: “ + oom.stackLength); throw e; }}运行结果Stack length: 718Exception in thread “main” java.lang.StackOverflowError分析：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者确切地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。理解：操作系统分配给每个进程的内存是有限的，虚拟机提供了参数来控制 Java 堆和方法区的这两部分内存的最大值。剩余的内存 -Xms（最大堆容量） -MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略不计。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈瓜分了。每个线程分配到的栈容量越大，可以建立的线程数量自然越少，建立线程时就越容易把剩下的内存耗尽。探索：出现 SOF 异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的）达到 1000 - 2000 完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果建立过多线程导致内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过 减少最大堆 和 减少栈容量 来换更多的线程。4.2.2 - OutOfMemoryError测试环境VM Args: -Xss2M // 栈内存容量测试代码：创建线程导致内存溢出异常private void neverStop() { while (true) { }}// 循环开启线程public void stackLeakByThread() { while (true) { new Thread(this::neverStop).start(); }}public static void main(String[] args) { JavaVMStackOOM oom = new JavaVMStackOOM(); oom.stackLeakByThread();}运行结果Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread4.3 - 方法区和运行时常量池溢出概述：由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。脑补：String.intern() 是一个 Native 方法，它的作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。在 JDK1.6 以及之前的版本中，由于常量池分配在永久代内，我们可以通过 -XX:PermSize 和 -XX:MaxPermSize 限制方法区的大小名，从而间接限制其中常量池的容量。4.3.1 - OutOfMemoryError测试环境-XX:PermSize=10M // 方法区最小值-XX:MaxPermSize=10M // 方法区最大值测试代码public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); long i = 0; while (true) { list.add(String.valueOf(i++).intern()); }}运行结果Exception in thread “main” java.lang.OutOfMemoryError: PermGen spaceeat java.lang.String.intern(Native Method)at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)分析：从运行结果中可以看到，运行时常量池溢出，在 OutOfMemoryError 后面跟随的提示信息是 PermGen space，说明运行时常量池属于方法区（HotSpot 虚拟机中的永久代）的一部分。4.3.2 - String 常量池测试使用 JDK1.7 运行这段程序就不会得到相同的结果，while 循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响。测试代码String str1 = new StringBuilder(“计算机”).append(“软件”).toString();System.out.println(str1.intern() == str1);String str2 = new StringBuilder(“ja”).append(“va”).toString();System.out.println(str2.intern() == str2);分析：JDK1.6：会得到两个 false，而在 JDK1.7 中运行，会得到一个 true 和一个 false。产生差异的原因是：是 JDK1.6 中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由 StringBuilder 创建的字符串实例在 Java 堆上，所以必然不是同一个引用，将返回 falseJDK1.7：intern() 实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此 intern() 返回的引用和由 StringBuilder 创建的那个字符串实例是同一个。对 str2 比较返回 false 是因为 java 这个字符串在执行 StringBuilder.toString() 之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而 计算机软件 这个字符串是首次出现的，因此返回 true。4.3.3 - 测试设计思路方法区用于存放 Class 的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本思路就是运行时产生大量的类去填满方法区，直到溢出。另外的，直接使用 Java SE API 也可以动态产生类（如反射时的 GeneratedConstorAccessor 和动态代理等）。4.3.4 - 总结方法区溢出是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量的 Class 的应用中，需要特别注意类的回收情况。这类场景除了上面提到的程序使用了 CGLib 字节码增强和动态语言之外，常见的还有：大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。4.4 - 本机直接内存溢出概述：DirectMemory 容量可以通过 -XX:MaxDirectMemorySize 指定，如果不指定，则默认与 Java 堆最大值（-Xmx指定）一样，下面的测试代码越过了 DirectByteBuffer 类，直接通过反射获取 Unsafe 实例进行内存分配（Unsafe 类的 getUnsafe() 方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有 rt.jar 中的类才能使用 Unsafe 的功能）。因为，虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是 unfase.allocateMemory()。测试代码private static final int _1MB = 1024 * 1024;public static void main(String[] args) throws Exception { Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) { unsafe.allocateMemory(_1MB); }}运行结果Exception in thread “main” java.lang.OutOfMemoryErrorat sun.misc.Unsafe.allocateMemory(Native Method)at org.fenixsoft.oom.DMOOM.main(DMOOM.java:20)分析：由 DirectMemory 导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看到明显的异常，如果发现 OOM 之后 Dump 文件很小，而程序中又直接或间接使用了 NIO，那就可以考虑检查一下是不是这方面的原因。悄悄话 🌈和大家说一声抱歉，这么久才完成了我的第二篇读书笔记，其中大家可以看到，文字性的内容多是一方面，原作者的阐述中是有很大一部分是比较严谨性的且全面性的，这也导致了行文中的内容分类是比较模糊的，这篇读书笔记是我在整理过了一遍之后再次按照内容分类整理出来的。目的是将原本散碎的知识点根据不同部分规整到一起，其中也深深体会到了原作者著书的不宜。上一篇读书笔记发布至今大概一周，每天都能看到阅读量和点赞数的提升，这时刻提醒我要继续写出更多、更高质量的文章来和大家分享，同时也衷心感谢关注和支持我的简友，如果没有你们我真不知道能不能完成我后续的文章。关于 《深入理解 Java 虚拟机》的写作最近可能要放缓了，因为马上要开学了，需要投入到全新的知识的学习中去，但我答应大家一定会在空余时间尽量完成该专题的写作。还有是之前欠大家的 《JavaSE 成长之路》的部分内容我会在这几天中尽力补全，也请大家继续关注。之前关注了我的 JavaSE 成长之路 专题的小伙伴，接下来的几天我也会将我之前的笔记整理出来陆续发布到这个专题之中，希望能和大家多多交流。彩蛋 🐣最近在拜读同名一书 《深入理解 Java 虚拟机》并会与大家分享我的读书笔记 深入理解 Java 虚拟机，有兴趣的朋友可以一同交流进步。如果你觉得我的分享对你有帮助的话，请在下面👇随手点个喜欢 💖，你的肯定才是我最大的动力，感谢。 文章转自：http://www.jianshu.com/p/989c90f339b9 原文作者：SawyerZh","categories":[],"tags":[]},{"title":"深入理解 Java 虚拟机（一）走近 Java(转)","slug":"深入理解-Java-虚拟机（一）走近-Java(转)","date":"2016-04-05T19:48:04.000Z","updated":"2017-03-08T08:35:31.000Z","comments":true,"path":"2016/04/05/深入理解-Java-虚拟机（一）走近-Java(转)/","link":"","permalink":"http://yoursite.com/2016/04/05/深入理解-Java-虚拟机（一）走近-Java(转)/","excerpt":"总述：Java 不仅是一门编程语言，还是一个由一系列 计算机软件 和 规范 形成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于 嵌入式系统。 移动终端 。 企业服务器 。 大型机等各种场合。","text":"总述：Java 不仅是一门编程语言，还是一个由一系列 计算机软件 和 规范 形成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于 嵌入式系统。 移动终端 。 企业服务器 。 大型机等各种场合。 特点：Java 能获得如此广泛的认可，除了它拥有一门 结构严谨、面向对象 的编程语言之外，还有须有不可忽视的有点，主要有如下几点👇。 它摆脱了硬件平台的束缚，实现了 一次编写，到处运行 的越界问题。 它实现了 热点代码检测 和 运行时编译及优化 ，这使得 Java 应用能随着运行时间的增加而获得更好的性能。 它有一套完善的应用程序接口，还有无数来自商业机构合开源社区的第三方类库来帮助它实现各种各样的功能。 后面我们会一起学习 Java 技术中最重要的那些特性和实现原理，在本篇文章中，将会重点介绍 Java 技术体系内容以及 Java 的历史、现在和未来的发展趋势。1.2 - Java 技术体系从广义上讲，Clojure、JRuby、Groovy 等运行于 Java 虚拟机上的语言及其相关的程序都属于 Java 技术体系中的一员。如果仅从传统意义上来看，Sun官方所定义的 Java 技术体系包括以下几个组成部分👇Java 程序设计语言。各种硬件平台上的 Java 虚拟机。Class 文件格式。Java API 类库。来自商业机构和开源社区的第三方 Java 类库。 我们可以将 Java 程序设计语言、Java 虚拟机、Java API 类库这三部分统称为 JDK（Java Development Kit），JDK 是用于支持 Java 程序开发的最小环境。另外，可以把 Java API 类库中的 Java SE API 子集和 Java 虚拟机这两部分统称为 JRE（Java Runtime Environment），JRE 是支持 Java 程序运行的标准环境。JVM 结构图如下所示 👇JVM 结构图Java Language 体系图如下所示 👇Java LanguageJava 技术体系可以分为4个平台，分别是Java Card：支持一些 Java 小程序（Applets）运行在小内存设备（如智能卡）上的平台。JavaME（Micro Edition）：支持 Java 程序运行在移动终端（手机、PDA）上的平台。JavaSE（Standard Edition）：支持面向桌面级应用（如 Windows 下的应用程序）的 Java 平台，提供了完整版的 Java 核心 API，这个版本以前也称为 J2SE。JavaEE（Enterprise Edition）：支持使用多层架构的企业应用（如 ERP、CRM 应用）的 Java 平台，除了提供 JavaSE API 外，还对其做了大量的扩充并提供了相关的部署支持，这个版本以前称为 J2EE。1.3 - Java 发展史从1996年 第一个 Java 版本诞生到现在已经有了20几年时间，其中诞生了无数和 Java 相关的产品、技术和标准，让我们一同回顾下 Java 的发展轨迹和历史变迁。Java-version-history1994-04：由 James Gosling 博士领导的绿色计划（Green Project） 开始启动，此计划的目的是开发一种能够在各种消费性电子产品（如机顶盒、冰箱、收音机等）上运行的程序架构。这个计划的产品就是 Java 语言的前身：Oak（橡树）。Oak 当时在消费品市场上并不算成功，但随着 1995 年互联网潮流的兴起，Oak 迅速找到了最适合自己发展的市场定位并蜕变成为 Java 语言。1994-05-23：Oak 语言改名为 Java，并且在 SunWorld 大会上正式发布 Java1.0 版本。Java 语言第一次提出了 Write Once, Run Anywhere 的口号。1996-01-23：JDK 1.0 发布，Java 语言有了第一个正式版本的运行环境。JDK 1.0 提供了一个纯解释执行的 Java 虚拟机实现（Sun Classic VM）。JDK 1.0 版本的代表技术包括：（Java 虚拟机、Applet、AWT 等）。1996-04：10个最主要的操作系统供应商申明将在其产品中嵌入 Java 技术。同年 9月，已有大约 8.3 万个网页应用了 Java 技术来制作。在 1996年5月底，Sun 公司于美国旧金山举行了 首届 JavaOne 大会，从此 JavaOne 成为全世界数百万 Java 语言开发者每年一度的技术盛会。1997-02-19：Sun 公司发布了 JDK 1.1，Java 技术的一些最基础的支撑点（JDBC 等）都是在 JDK 1.1 版本中发布的，JDK 1.1版本的代表技术有（1.JAR 文件格式、2.JDBC、3.JavaBeans、4.RMI）。Java 语法也有了一定的发展，如内部类（Inner Class）和反射（Reflection） 都是在这个时候出现的。1998-12-04：JDK 迎来了一个里程碑式的版本 JDK 1.2，工程代号为 Playground（竞技场），Sun 在这个版本中把 Java 技术体系拆分为 3 个方向，分别是：面向桌面应用开发的 J2SE（Java 2 Platform，Standard Edition）面向企业级开发的 J2EE（Java 2 Platform，Enterprise Edition）面向手机等移动端开发的 J2ME（Java 2 Platform，Micro Edition）。在这个版本中出现的代表性技术非常多（EJB、Java Plug-in、Java IDL、Swing 等），并且这个版本中 Java 虚拟机第一次内置了 JIT（Just In Time） 编译器（JKD 1.2中曾并存过3个虚拟机，Classic VM、HotSpot VM 和 Exact VM，其中 Exact VM 只能以外挂的形式使用 JIT 编译器）。在语言和 API 级别上，Java 添加了 strictfp 关键字与现在 Java 编码中极为常用的一系列 Collection 集合类。1999-04-27：HotSpot 虚拟机发布，HotSpot 最初由一家名为 Longview Technologies 的小公司开发，因为其优异的表现，这家公司在 1997 年被 Sun 公司收购了。HotSpot 虚拟机发布时是作为 JDK 1.2的附加程序提供的，后来它成为了 JDK 1.3 及之后所有版本的 Sun JDK 的默认虚拟机。2002-02-13：JDK 1.4发布，工程代号为 Merlin（灰背隼）。JDK 1.4 是 Java 真正走向成熟的一个版本，Compaq、Fujitsu、SAS、Symbian、IBM 等著名公司都有参与甚至实现自己独立的 JDK 1.4。仍然有许多主流应用（Spring、Hibernate、Struts 等）能直接运行在 JDK 1.4 之上，或者继续发布能运行在 JDK 1.4 上的版本。JDK 1.4 同样发布了很多新的技术特性（正则表达式、异常链、NIO、日志类、XML解析器 和 XSLT转换器 等）。2004-09-30：JDK 1.5 发布（从这个版本开始官方正式文档宣传上已经不再使用类似 JDK1.5的命名，只有在程序员内部使用的开发版本号，例如 java -version 的输出，而公开版本号则改为 JDK 5），工程代号 Tiger（老虎）。从 JDK 1.2 以来，Java 在语法层面上的变换一直很小，而 JDK 1.5 在 Java 语法易用性上做出了非常大的改进。例如（自动装箱、泛型、动态注释、枚举、可变长参数、foreach循环 等）语法特性都是在 JDK 1.5 中加入的。在虚拟机和 API 层面上，这个版本改进了 Java 的内存模型（Java Memory Model, JVM）、提供了 java.util.concurrent 并发包等。2006-12-11：JDK 1.6 发布，工程代号 Mustang（野马）。在这个版本中 Sun 终结了 JDK 1.2 开始已经有8年历史的 J2EE、J2SE、J2ME 的命名方式，启用 Java SE 6、Java EE 6、Java ME 6的命名方式。JDK 1.6 的改进包括：提供动态语言支持（通过内置 Mozilla JavaScript Rhino 引擎实现）、提供编译 API 和微型 HTTP 服务器 API 等。同时，这个版本对 Java 虚拟机内部做了大量改进，包括 锁与同步、垃圾回收、类加载 等方面的算法都有相当多的改动。2006-11-13：JavaOne 大会上，Sun 公司宣布最终会将 Java 开源，并在随后的一年多时间内，陆续将 JDK 的各个部分在 GPL v2（GNU General Public License v2）协议下 公开了源码，并建立了 OpenJDK 组织对这些源码进行独立管理。除了极少量的产权代码（Encumbered Code，这部分代码大多是 Sun 本身也无权限进行开源处理的）外，OpenJDK 几乎包括了 Sun JDK 的全部代码，OpenJDK 的质量主管曾经表示，在 JDK 1.7 中，Sun JDK 和 OpenJDK 除了代码文件头的版权注释之外，代码基本上完全一样，所以 OpenJDK 7 与 Sun JDK 1.7 本质上就是同一套代码库开发的产品。JDK 1.6 发布以后，由于代码复杂性的增加、JDK 开源、开发 JavaFX、经济危机及 Sun 收购案等原因，Sun 在 JDK 发展以外的事情上耗费了很多资源，JDK 的更新并没有再维持两年发布一个版本的发展速度☹️。2009-02-19：工程代号为 Dolphin（海豚）的 JDK 1.7 完成了其第一个里程碑版本。根据 JDK 1.7 的功能规划，一共设置了10个里程碑。最后一个里程碑版本原计划与 2010 年 9 月 9 日技术，但由于各种原因，JDK 1.7 最终无法按计划完成。从 JDK 1.7 最开始的功能规划来看，它本应是一个包含许多重要改进的 JDK 版本，其中 Lambda 项目（Lambda表达式、函数式编程）、Jigsaw项目（虚拟机模块化支持）、动态语言支持、GarbageFirst收集器 和 Coin项目（语言细节进化）等子项目对于 Java 业界都会产生深远的影响。在 JDK 1.7 开发期间，Sun 公司由于相继在技术竞争和商业竞争中都陷入泥潭，公司的股票市值跌至仅有高峰时期的 3%🤕（心疼），已无力推动 JDK 1.7 的研发工作按正常计划进行。为了尽快结束 JDK 1.7 长期 ”跳票” 的问题，Oracle 公司收购 Sun 公司后不久便宣布将实行 “B计划”，大幅裁剪了 JDK 1.7 预订目标，以便保证 JDK 1.7 的正式版能够与 2011年7月28日准时发布。”B计划” 把不能按时完成的 Lambda 项目、Jigsaw 项目和 Coin 项目的部分改进延迟到 JDK 1.8之中。最终，JDK 1.7 的主要改进包括：提供新的 G1收集器、加强对非 Java 语言的调用支持、升级类加载架构 等。2009-04-20：Oracle 公司宣布正式以74亿美元的价格收购 Sun 公司，Java 商标从此正式归 Oracle 所有（ Java 语言本身并不属于哪家公司所有，它由 JCP 组织进行管理，尽管 JCP 主要是由 Sun 公司或者说 Oracle 公司所领导的 ）。由于此前 Oracle 公司已经收购了另外一家大型的中间件企业 BEA 公司，在完成对 Sun 公司的收购之后，Oracle 公司分别从 BEA 和 Sun 中取得了目前三大商业虚拟机其中两个：JRockit 和 HotSpot，Oracle 公司宣布在未来的 1-2年的时间内，将把这两个优秀的虚拟机相互取长补短，最终合二为一。在 2011年的 JavaOne 大会上，Oracle 公司还提到了 JDK 1.9 的长远规划，希望未来的 Java 虚拟机能够管理数以 GB 计的 Java 堆🙀，能够更高效地与本地代码继承，并且令 Java 虚拟机运行时尽可能少人工干预，能够自动调节。1.4 - Java 虚拟机发展史上一节从整个 Java 技术的角度观察了 Java 技术的发展，许多 Java 程序员都会潜意识地把它与 Sun 公司的 HotSpot 虚拟机等同看待，也许还有一些人会注意到 BEA JRockit 和 IBM J9，但对 JVM 的认识不仅仅只有这些。从 1996 年初 Sun 公司发布的 JDK 1.0 中所包含的 Sun Classic VM 到今天，曾经涌现、湮灭过许多经典或优秀或有特色的虚拟机实现，在这一节中我们一起来回顾一下 Java 虚拟机家族的发展轨迹和历史变迁。1.4.1 - Sun Classic / Exact VM从今天的视角来看，Sun Classic VM 的技术可能很原始，这款虚拟机的使命也早已终结。但仅凭它 世界上第一款商用 Java 虚拟机 的头衔，就足够有让历史记住它的理由🤔。1996-01-23：Sun 公司发布 JDK 1.0，Java 语言首次拥有了商用的正式运行环境，这个 JDK 中所带的虚拟机就是 Classic VM。这款虚拟机只能使用纯解释器方式来执行 Java 代码，如果要使用 JIT 编译器，就必须进行外挂。但是加入外挂了 JIT 编译器，JIT 编译器就完全接管了虚拟机的执行系统，解释器便不再工作了。用户在这款虚拟机上执行 java -version 命令，将会看到类似下面这行输出java version “1.2.2”Classic VM (build JDK-1.2.2-001, green threads, sunwjit)其中的 sunwjit 就是 Sun 提供的外挂编译器，其他类似的外挂编译器还有 Symantec JIT 和 shuJIT 等。由于 解释器 和 编译器 不能配合工作，这就意味着如果要使用编译器执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论他们执行的频率是否具有编译的价值。基于程序响应时间的压力，这些编译器根本不敢应用编译耗时稍高的优化技术，因此这个阶段的虚拟机即使使用了 JIT 编译器输出本地代码，执行效率也和传统的 C/C++ 程序有很大差距，Java 语言很慢 的形象就是在这时候开始在用户心中树立起来的。Sun 的虚拟机团队努力去解决 Classic VM 所面临的各种问题，提升运行效率。在 JDK 1.2 时，曾在 Solaris 平台上发布过一款名为 Exact VM 的虚拟机，它的执行系统已经具备现代高性能虚拟机的雏形：如 两级即时编译器、编译器与解释器混合工作模式 等。Exact VM 因它使用 准确式内存管理（Exact Memory Management）而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。例如内存中有一个 32 位的整数 123456，它到底是 reference 类型指向 123456 的内存地址还是一个数值为 123456 的整数，虚拟机将有能力分辨出来，这样才能在 GC（垃圾收集）的时候准确判断堆上的数据是否还可以被使用。由于使用了准确式内存管理，Exact VM 可以抛弃以前 Classic VM 基于 handler 的对象查找方式（原因是进行 GC 后对象将可能会被移动位置，如果将地址为 123456 的对象移动到 654321，在没有明确信息表明内存中哪些数据是 reference 的前提下，虚拟机是不敢把内存中所有 123456 的值改为 654321 的，所以要使用句柄来保持 refrence 值的稳定），这样每次定位对象都少了一次间接查找的开销，提升执行性能。虽然 Exact VM 的技术相对 Classic VM 来说先进了许多，但是在商业应用上只存在了很短暂的时间就被更为优秀的 HotSpot VM 所取代，甚至还没有来得及发布 Windows 和 Linux 平台下的商用版本。而 Classic VM 的生命周期则相对长了许多，它在 JDK 1.2 之前是 Sun JDK 中唯一的虚拟机，在 JDK 1.2时，它与 HotSpot VM 并存，但默认使用的是 Classic VM，而在 JDK 1.3 时，HotSopt VM 成为默认虚拟机，但 Classic VM 仍作为虚拟机的 “备用选择” 发布，直到 JDK 1.4 的时候，Classic VM 才完全退出商用虚拟机的历史舞台，与 Exact VM 一起进入了 Sun Labs Research VM 中 😴。1.4.2 - Sun HotSpot VM提起 HotSpot VM，相信所有 Java 程序员都知道，它是 Sun JDK 和 OpenJDK 中所带的虚拟机，也是目前 使用范围最广的 Java 虚拟机。但不一定所有人都知道的是，这个目前看来 ”血统纯正” 的虚拟机在最初并非由 Sun 公司开发，而是一家名为 Longview Technologies 的小公司设计的；设置这个虚拟机最初并非是为 Java 语言而开发的，它来源于 Strongtalk VM，而这款虚拟机中相当多的技术又是来源于一款 Self 语言实现 “可能达到 C 语言 50% 以上的执行效率” 的目标而设计的虚拟机，Sun 公司注意到了这款虚拟机在 JIT 编译上有许多优秀的理念和实际效果，在 1997 年收购了 Longview Technologies 公司，从而获得了 HotSpot VM。HotSpot VM 继承了 Sun 之前两款商用虚拟机的优点 =&gt; 准确式内存管理，也有许多自己新的技术优势，如它名称中的 HotSpot 指的就是它的 热点代码探测技术（其实两个 VM 基本上是同时期的独立产品，HotSpot 还稍早一些，HotSpot 一开始就是准确式 GC，而 Exact VM 中也有与之几乎一样的热点探测。为了 Exact VM 和 HotSpot VM 哪个成为 Sun 主要支持的 VM 产品，在 Sun 公司内部还有过争论，HotSpot 打败 Exact 并不能算技术上的胜利），HotSpot VM 的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知 JIT 编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会被分别触发 标准编译 和 OSR（栈上替换） 编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序相应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。在 2006 年的 JavaOne 大会上，Sun 公司宣布最终会把 Java 开源，并在随后的一年，陆续将 JDK 的各个部分（其中当然也包括了 HotSpot VM）在 GPL 协议下公开了源码，并在此基础上建立了 OpenJDK。这样，HotSpot VM 便成为了 Sun JDK 和 OpenJDK 两个实现极度接近的 JDK 项目的共同虚拟机。1.4.3 - Sun Mobile-Embedded VM / Meta-Circular VMSun 公司所研发的虚拟机可不仅有前面介绍的服务器、桌面领域的商用虚拟机，除此之外，Sun 公司面对 移动 和 嵌入式市场，也发布过虚拟机产品，另外还有一类虚拟机，在设计之初就没报有商用目的，仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现。这些虚拟机对于大部分不从事相关领域开发的 Java 程序员来说可能比较陌生，Sun 公司发布的其他 Java 虚拟机有KVM：K 是 Kilobyte 的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。在 Android、iOS 等智能手机操作系统出现前曾经在手机平台上得到非常广泛的应用。CDC/CLDC HotSpot Implementation：CDC/CLDC全称是 Connected（Limited）Device Configuration，在 JSR-136、JSR-218 规范中进行定义，它希望在手机、电子书、PDA 等设备上建立统一的 Java 编程接口，而 CDC-HI VM 和 CLDC-HI VM 则是它们的一组参考实现。CDC/CLDC 是整个 JavaME 的重要支柱，但从目前 Android 和 iOS 二分天下的移动数字设备市场看来，在这个领域中，Sun 的虚拟机所面临的局面远不如服务器和桌面领域乐观。Squawk VM：Squawk VM 由 Sun 公司开发，运行于 Sun SPOT（Sun Small Programmable Object Technology，一种手持的 WiFi 设备），也曾经运用于 Java Card。这是一个 Java 代码比重很高的嵌入式虚拟机实现，其中诸如类加载器、字节码验证器、垃圾回收器、解释器、编译器和线程调度都是 Java 语言本身完成的，仅仅靠 C 语言来编写设备 I/O 和必要的本地代码。JavaInJava：JavaInJava 是 Sun 公司于 1997-1998 年间研发的一个实验室性质的虚拟机，从名字就可以看出，它试图以 Java 语言来实现 Java 语言本身的运行环境，即所谓的 “元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）。它必须运行在另外一个宿主虚拟机之上，内部没有 JIT 编译器，代码只能以解释模式执行。在 20世纪末主流 Java 虚拟机都未能很好解决性能问题的时代，开发这种项目，其执行速度可想而知。Maxine VM：Maxine VM 和上面的 JavaInJava 非常相似，它也是一个几乎全部以 Java 代码实现（只有用于启动 JVM 的加载器使用 C 语言编写）的元循环 Java 虚拟机。这个项目于 2005 年开始，到现在仍然在发展之中，比起 JavaInJava，Maxine VM 就显得 “靠谱” 很多，它有先进的 JIT 编译器和垃圾回收器（但没有解释器），可以在宿主模式或独立模式下执行，其执行效率已经接近了 HotSpot Client VM 的水平。1.4.4 BEA JRockit / IBM J9 VM前面介绍了 Sun 公司的各种虚拟机，除了 Sun 公司以外，其他组织、公司也研发过不少虚拟机实现，其中规模最大、最著名的就是 BEA 和 IBM 公司了。JRockit VM 曾经号称 世界上速度最快的 Java 虚拟机（广告词，貌似 J9 VM 也这样说过🙄），它是 BEA 公司在 2002 年从 Appeal Virtual Machines 公司收购的虚拟机。BEA 公司将其发展为一款 专门为服务器硬件和服务器端应用场景高度优化的虚拟机，由于专注于服务器端应用，它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。除此之外，JRockit 的垃圾收集器和 MissionControl 服务套件等部分的实现，在众多 Java 虚拟机中也一直处于领先水平。IBM J9 VM 并不是 IBM 公司唯一个 Java 虚拟机，不过是目前其主力发展的 Java 虚拟机。IBM J9 VM 原本是内部开发代号，正式名称是 “IBM Technology for Java Virtual Machine”，简称 IT4J，只是这个名字太拗口了一点，普及程度不如 J9。J9 VM 最初是由 IBM Ottawa 实验室一个名为 SmallTalk 的虚拟机扩展而来，当时这个虚拟机有一个 bug 是由 8k 值定义错误引起的，工程师花了很长时间终于发现并解决了这个错误，此后这个版本的虚拟机就称为 K8 了，后来扩展出支持 Java 的虚拟机就被称为 J9 了。与 BEA JRockit 专注于服务器端应用不同，IBM J9 的市场定位与 Sun HotSpot 比较接近，它是一款设计上 从服务器端到桌面应用再到嵌入式都全面考虑的多用途虚拟机，J9 的开发目的是做为 IBM 公司各种 Java 产品的执行平台，它的主要市场是和 IBM 产品（如 IBM WebSphere 等）搭配以及在 IBM AIX 和 z/OS 这些平台上部署 Java 应用。1.4.5 - Azul VM / BEA Liquid VM我们平时所提及的 “高性能 Java 虚拟机”，一般是指 HotSpot、JRockit、J9这类在通用平台上运行的商用虚拟机，但其实 Azul VM 和 BEA Liquid VM 这类特定硬件平台专有的虚拟机才是 高性能 的武器。Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 Java 虚拟机，每个 Azul VM 实例都可以管理至少数十个 CPU 和数百 GB 内存的硬件资源🙀，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、为专有硬件优化的线程调度 等优秀特征。在 2010 年，Azul System 公司开始从硬件转向软件，发布了自己的 Zing JVM，可以在通用的 x86 平台上提供接近于 Vega 系统的特性。Liquid VM 即是现在的 JRockit VM 虚拟化版本，Liquid VM 不需要操作系统的支持，或者说它自己 本身实现了一个专有操作系统的必要功能，如文件系统、网络操作等。由虚拟机越过通用操作系统直接控制硬件 可以获得很多好处，如在线程调度时，不需要再进行内核态 / 用户态的切换等，这样可以最大限度地发挥硬件的功能，提升 Java 程序的执行性能。1.4.6 - Apache Harmony / Google Android Dalvik VM这节介绍的两个虚拟机只能称作 “虚拟机”，而不能称做 “Java 虚拟机”，但是这两款虚拟机（以及所代表的技术体系）对最近几年的 Java 世界产生了非常大的影响和挑战，甚至有些悲观的评论家认为成熟的 Java 生态系统有崩溃的可能。Apache Harmony 是一个 Apache 软件基金会下以 Apache License 协议开源的实际兼容于 JDK 1.5 和 JDK 1.6 的 Java 程序运行平台，这个介绍相当拗口。它包含自己的虚拟机和 Java 库，用户可以在上面运行 Eclipse、Tomcat、Maven 等常见的 Java 程序，但是它没有通过 TCK 认证，所以我们不得不用那么长一串拗口的语言来介绍它，而不能用一句 “Apache 的 JDK” 来说明。如果一个公司要宣布自己的运行平台 “兼容于 Java 语言”，那就必须要通过 TCK（Technology Compatibility Kit）的兼容性测试。Apache 基金会曾经要求 Sun 公司提供 TCK 的使用授权，但是一直遭到拒绝，直到 Oracle 公司收购了 Sun 公司之后，双方关系越闹越僵，最终导致 Apache 愤然退出 JCP（Java Community Process） 组织，这是目前为止 Java 社区最严重的一次 “分裂”。在 Sun 将 JDK 开源形成 OpenJDK 之后，Apache Harmony 开源的优势被极大地削弱，甚至连 Harmony 项目的最大参与者 IBM 公司也宣布辞去 Harmony 项目管理主席的职位，并参与 OpenJDK 项目的开发。虽然 Harmony 没有经历过真正大规模的商业运作，但是它的许多代码（基本上是 Java 库部分的代码）被吸纳进 IBM 的 JDK7 实现及 Google Android SDK 之中，尤其是对 Android 的发展起到了很大的推动作用。说到 Android，这个时下最热门的移动数码设备平台在最近几年间的发展过程中所取得的成果已经远远超越了 Java ME 在过去十多年所取得的成果，Android 让 Java 语言真正走进了移动数码设备领域，只是走的并非 Sun 公司原本想象的那一条路。Dalvik VM 是 Android 平台的核心组成部分之一，它的名字来源于冰岛一个名为 Dalvik 的小渔村。Dalvik VM 并不是一个 Java 虚拟机，它没有遵循 Java 虚拟机规范，不能直接执行 Java 的 Class 文件，使用的是 寄存器架构 而不是 JVM 中常见的 栈架构。但是它与 Java 又有着千丝万缕的联系，它执行的 dex（Dalvik Executable）文件可以通过 Class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等。目前 Dalvik VM 随着 Android 一起处于一个迅猛发展阶段，在 Android 2.2 中已提供即时编译器实现，在执行性能上有了很大的提高。1.4.7 - Microsoft JVM 及其他在十几年的 Java 虚拟机发展过程中，除去上面介绍而那些被大规模商业应用过的 Java 虚拟机外，还有许多虚拟机是不为人知的或者曾经 “绚丽” 过但最终湮灭的。我们以其中微软公司的 JVM 为例来介绍一下。也许 Java 程序员听起来可能会觉得惊讶，微软公司曾经是 Java 技术的铁杆支持者（也必须承认，与 Sun 公司争夺 Java 控制权，令 Java 从跨平台技术变为绑定在 Windows 上的技术是微软公司的主要目的）。在 Java 语言诞生初期（1996年-1998年，以 JDK1.2 发布为界），它的主要应用之一是在浏览器中运行 Java Applets 程序，微软公司为了在 IE3 中支持 Java Applets 应用而开发了自己的 Java 虚拟机，虽然这款虚拟机只有 Windows 平台的版本，却是当时 Windows 下性能最好的 Java 虚拟机，它在 1997年和1998年连续两年获得了《PC Magazine》杂志的 “编辑选择奖”。但好景不长，在 1997年10月，Sun 公司正式以侵犯商标、不正当竞争等罪名控告微软公司，在随后对微软公司的垄断调查之中，这款虚拟机也曾经作为证据之一被呈送法庭。这场官司的结果是微软公司赔偿 2000 万美金给 Sun 公司（最终微软公司因垄断赔偿给 Sun 公司的总金额高达 10 亿美元），承诺终止其 Java 虚拟机的发展，并逐步在产品中移除 Java 虚拟机相关功能。具有讽刺意味的是，在最后 Windows XP SP3 中 Java 虚拟机被完全抹去的时候，Sun 公司却又到处登报希望微软公司不要这样做。Windows XP 高级产品经理 Jim Cullinan 称：”我们花了 3 年时间和 Sun 打官司，当时他们试图阻止我们在 Windows 中支持 Java，现在我们这样做了，可他们又在抱怨，这太具有讽刺意味了。”如果当前 Sun 公司没有起诉微软公司，微软公司继续保持对 Java 技术的热情，那 Java 的世界会变得怎么样呢？.NET 技术是否会发展起来？但历史是没有假设的。还有一些 Java 虚拟机是没有介绍到的。1.5 - 展望 Java 技术的未来在 2005 年，Java 技术诞生 10 周年的 SunOne 技术大会上，Java 语言之父 James Gosling 做了一场题为 “Java 技术下一个十年” 的演讲。笔者不具备 James Gosling 博士那样高屋建瓴的视角，这里仅从 Java 平台中几个新生的但已经开始展现出蓬勃之势的技术发展点来看一下后续 JDK 版本的一些很有希望的技术重点。1.5.1 - 模块化模块化是解决应用系统与技术平台越来越服复杂、越来越庞大问题的一个重要途径。无论是开发人员还是产品最终用户，都不希望为了系统中一小块的功能而不得不下载、安装、部署及维护整套庞大的系统。站在整个软件工业化的高度来看，模块化是建立各种功能的标准件的前提。最近几年 OSGi 技术的迅速发展、各个厂商在 JCP 中对模块化规范的激烈斗争，都能充分说明模块化技术的迫切和重要。在未来的 Java 平台中，很可能会对模块化提出语法层面的支持。早在 2007 年，Sun 公司就提出过 JSR-277：Java 模块系统（Java Module System），试图建立 Java 平台的模块化标准，但受挫于以 IBM 公司为主导提交的 JSR-291：Java SE 动态组件支持（Dynamic Component Support for Java SE，这实际就是 OSGi R4.1）。由于模块化规范主导权的重要性，Sun 公司不能接受一个无法由它控制的规范，Sun 公司再次提交了一个新的规范请求文档 JSR-294：Java 编程语言中的改进模块性支持（Improved Modularity Support in the Java Programming Language），尽管这个 JSR 仍然没有通过，但是 Sun 公司已经独立于 JCP 专家组在 OpenJDK 里建立了一个名为 Jigsaw（拼图）的子项目来推动这个规范在 Java 平台中转变为具体的实现。Java 模块化之争目前还没有结束，OSGi 已经发布到 R5.0 版本，而 Jigsaw 从 Java 7 延迟至 Java 8，在 2012 年 7 月又不得不宣布推迟到 Java9 中发布，从这点看来，Sun 在这场战争中处于劣势，但无论胜利者是哪一方，Java 模块化已经成为一项无法阻挡的变革潮流。1.5.2 - 混合语言当单一的 Java 开发已经无法满足当前软件的复杂需求时，越来越多基于 Java 虚拟机的语言开发被应用到软件项目中，Java 平台上的多语言混合编程正成为为主流，每种语言都可以针对自己擅长的方面更好地解决问题。试想一下，在一个项目之中，并行处理用 Clojure 语言编写，展示层使用 JRuby / Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为它们最终都运行在一个虚拟机之上。在最近的几年里，Clojure、JRuby、Groovy 等新生语言的使用人数不断增长，而运行在 Java 虚拟机（JVM）之上的语言数量也在迅速膨胀。通过特定领域的语言去解决特定领域的问题 是当前软件开发应对日趋复杂的项目需求的一个方向。Languages In The Java除了催生出大量的新语言外，许多已经有很长历史的程序语言也出现了基于 Java 虚拟机实现的版本，这样使得混合编程对许多以前使用其他语言的 “老” 程序员也具备相当大的吸引力，软件企业投入了大量资本的现有代码资产也能很好地保护起来。1.5.3 - 多核并行如今，CPU 硬件的发展方向已经从高频率转变为 多核心，随着多核时代的来临，软件开发越来越关注并行编程的领域。早在 JDK1.5 就已经引入 java.util.concurrent 包实现了一个粗粒度的并发框架。而 JDK1.7 中加入的 java.util.cuncurrent.forkjoin 包则是对这个框架的一次重要扩充。Fork / Join模式 是处理并行编程的一个经典方法。虽然不能解决所有的问题，但是在此模式的适用范围之内，能够轻松地利用多个 CPU 核心提供的计算资源来协作完成一个复杂的计算任务。通过利用 Fork / Join 模式，我们能够更加顺场地过渡到多核心时代。Fork / Join 模式在 Java 8 中，将会提供 Lambda 支持，这将会极大改善目前 Java 语言不适合 函数式编程 的现状（目前 Java 语言使用函数式编程并不是不可以，只是会显得很臃肿），函数式编程的一个重要优点就是这样的程序天然地适合 并行运行，这对 Java 语言在多核时代继续保持主流语言的地位有很大帮助。另外，在并行计算中必须提及的还有 OpenJDK 的子项目 Sumatra，目前显卡的算术运算能力、并行能力已经远远超过了 CPU，在图形领域以发掘显卡的潜力是近几年计算机发展的方向之一，例如 C 语言的 CUDA。Sumatra 项目就是为 Java 提供使用 GPU（Graphics Processing Units）和 APU（Accelerated Processing Units） 运算能力的工具，以后它将会直接提供 Java 语言层面的 API，或者为 Lambda 和其他 JVM 语言提供底层的并行运算支持。在 JDK 外围，也出现了专为满足并行计算需求的计算框架，如 Apache 的 Hadoop Map / Reduce，这是一个简单易懂的并行框架，能够运行在由上千个商用机器组成的大型集群上，并且能以一种可靠的容错方式并行处理 TB 级别的数据集。另外，还出现了诸如 Scala、Clojure 及 Erlang 等天生就具备并行计算能力的语言。1.5.4 - 进一步丰富语法Java 5 曾经对 Java 语法进行了一次扩充，这次扩充加入了自动装箱、泛型、动态注解、枚举、可边长参数、遍历循环 等语法，使得 Java 语言的精确性和易用性有了很大的进步。在 Java 7（由于进度压力，许多改进已推迟至 Java 8）中，对 Java 语言进行了另一次大规模的扩充。Sun（以被 Oracle 收购）专门为改进 Java 语法在 OpenJDK 中建立了 Coin 子项目来统一处理对 Java 语法的细节修改，如二进制数的原生支持、在 switch 语句中支持字符串、&lt;&gt;等操作符、异常处理的改进、简化变长参数方法调用、面向资源的 try-catch-finally 语句等都是在 Coin 项目之中提交的内容。除了 Coin 项目之外，在 JSR-355（Lambda Expressions for the Java TM Programming Language）中定义的 Lambda 表达式也将对 Java 的语法和语言习惯产生很大的影响，面向函数方式的编程可能会成为主流。1.5.5 - 64位虚拟机在几年之前，主流的 CPU 就开始支持 64 位架构了。Java 虚拟机也是在很早之前就退出了支持 64 位系统的版本。但 Java 程序运行在 64 位虚拟机上需要付出比较大的额外代价：首先是 内存问题，由于 指针膨胀 和各种 数据类型对齐补白 的原因，运行于 64 位系统上的 Java 应用需要消耗更多的内存，通常要比 32 位系统额外增加 10%-30% 的内存消耗；其次，多个机构的测试结果显示，64 位虚拟机的运行速度在各个测试项中几乎全面落后于 32 位虚拟机，两者大约有 15% 左右的性能差距。但是在 Java EE 方面，企业级应用经常需要使用超过 4GB 的内存，对于 64 位虚拟机的需求是非常迫切的，但由于上述原因，许多企业应用仍然选择使用虚拟集群等方式继续在 32 位虚拟机中进行部署。Sun 也注意到了这些问题，并做出了一些改善，在 JDK 1.6 Update14 之后，提供了普通对象指针压缩同能（-XX:+ UseCompressedOops，这个参数不建议显示设置，建议维持默认由虚拟机的 Ergonomics 机制自动开启），在执行代码时，动态植入压缩指令以节省内存消耗，但是开启压缩指针会增加执行代码数量，因为所有在 Java 堆里的、指向 Java 堆对象的指针都会被压缩，这些指针的访问就需要更多的代码才可以实现，并且并不只是读写字段才受影响，在实例方法调用、子类型检查等操作中也受影响，因为对象实例的引用也被压缩了。随着硬件的进一步发展，计算机终究会完全过渡到 64 位的时代，这是一件毫无疑问的事情，主流的虚拟机应用也终究会从 32 位发展至 64 位，而虚拟机对 64 位的支持也将会进一步完善。悄悄话 🌈最近刚刚结束了 JavaSE 部分课程的学习，趁着放假的时间深挖一下 Java 虚拟机，为后续的 Java 学习打下基础。计划用 2 周的时间全面学习一下 《深入理解 Java 虚拟机》一书，并且会将学习笔记分享到我的专题中。万事开头难，这本书原作者在前言中也已经写到，本书的读者应该熟练掌握 Java 语言或者是有多年 Java 开发经验，但是对于我一个 Java 刚入门的小白来说读起来可能会有一些困难，所以我想要开好这个头，也为下面的学习铺平道路第一章的内容我是全部精读了一遍然后写出来的，期间读到了 Sun 公司在它的晚年时对 Java 的 10 个里程碑设置，慨叹 Java 开发团队的管理者和工程师的前瞻性，也惋惜 Sun 公司对 Java 的开发因最终的资金、外部环境以及项目复杂度而最终流产。如果当初的 Sun 公司能处理好技术之外的事情，并将原计划的 JDK8 发布的话，想象不到这之后的开发语言会再次提升到什么样的一个高度。除了对 Java 语言的时代背景和技术背景的了解之外，也了解到了大量的关于虚拟机的一些基础知识和编程语言发展前景，也许这些知识在开发过程中不能明确指导我们的代码编写，但是却拓展了我个人对 Java 的了解，我觉得这也是一个作为开发者来说应有的编程之外的基础素养。之前关注了我的 JavaSE 成长之路 专题的小伙伴，接下来的几天我也会将我之前的笔记整理出来陆续发布到这个专题之中，希望能和大家多多交流。彩蛋 🐣最近在拜读同名一书 《深入理解 Java 虚拟机》并会与大家分享我的读书笔记 深入理解 Java 虚拟机，有兴趣的朋友可以一同交流进步。如果你觉得我的分享对你有帮助的话，请在下面👇随手点个喜欢 💖，你的肯定才是我最大的动力，感谢。 &lt;/div&gt; 原文引自：http://www.jianshu.com/p/4aa86f791beb 作者：SawyerZh","categories":[],"tags":[]},{"title":"理解Java虚拟机体系结构(转）","slug":"理解Java虚拟机体系结构(转)","date":"2016-03-23T02:48:04.000Z","updated":"2017-03-08T00:57:12.000Z","comments":true,"path":"2016/03/23/理解Java虚拟机体系结构(转)/","link":"","permalink":"http://yoursite.com/2016/03/23/理解Java虚拟机体系结构(转)/","excerpt":"1 概述 众所周知，Java支持平台无关性、安全性和网络移动性。而Java平台由Java虚拟机和Java核心类所构成，它为纯Java程序提供了统一的编程接口，而不管下层操作系统是什么。正是得益于Java虚拟机，它号称的“一次编译，到处运行”才能有所保障。","text":"1 概述 众所周知，Java支持平台无关性、安全性和网络移动性。而Java平台由Java虚拟机和Java核心类所构成，它为纯Java程序提供了统一的编程接口，而不管下层操作系统是什么。正是得益于Java虚拟机，它号称的“一次编译，到处运行”才能有所保障。 1.1 Java程序执行流程Java程序的执行依赖于编译环境和运行环境。源码代码转变成可执行的机器代码，由下面的流程完成：Java技术的核心就是Java虚拟机，因为所有的Java程序都在虚拟机上运行。Java程序的运行需要Java虚拟机、Java API和Java Class文件的配合。Java虚拟机实例负责运行一个Java程序。当启动一个Java程序时，一个虚拟机实例就诞生了。当程序结束，这个虚拟机实例也就消亡。Java的跨平台特性，因为它有针对不同平台的虚拟机。1.2 Java虚拟机Java虚拟机的主要任务是装载class文件并且执行其中的字节码。由下图可以看出，Java虚拟机包含一个类装载器（class loader），它可以从程序和API中装载class文件，Java API中只有程序执行时需要的类才会被装载，字节码由执行引擎来执行。当Java虚拟机由主机操作系统上的软件实现时，Java程序通过调用本地方法和主机进行交互。Java方法由Java语言编写，编译成字节码，存储在class文件中。本地方法由C/C++/汇编语言编写，编译成和处理器相关的机器代码，存储在动态链接库中，格式是各个平台专有。所以本地方法是联系Java程序和底层主机操作系统的连接方式。由于Java虚拟机并不知道某个class文件是如何被创建的，是否被篡改一无所知，所以它实现了一个class文件检测器，确保class文件中定义的类型可以安全地使用。class文件检验器通过四趟独立的扫描来保证程序的健壮性：class文件的结构检查类型数据的语义检查字节码验证符号引用验证Java虚拟机在执行字节码时还进行其它的一些内置的安全机制的操作，他们作为Java编程语言保证Java程序健壮性的特性，同时也是Java虚拟机的特性：类型安全的引用转换结构化的内存访问自动垃圾收集数组边界检查空引用检查1.3 Java虚拟机数据类型Java虚拟机通过某些数据类型来执行计算。数据类型可以分为两种：基本类型和引用类型，如下图：但boolean有点特别，当编译器把Java源码编译为字节码时，它会用int或byte表示boolean。在Java虚拟机中，false是由0表示，而true则由所有非零整数表示。和Java语言一样，Java虚拟机的基本类型的值域在任何地方都是一致的，不管主机平台是什么，一个long在任何虚拟机中总是一个64位二进制补码的有符号整数。对于returnAddress，这个基本类型被用来实现Java程序中的finally子句，Java程序员不能使用这个类型，它的值指向一条虚拟机指令的操作码。2 体系结构在 Java虚拟机规范中，一个虚拟机实例的行为是分别按照子系统、内存区、数据类型和指令来描述的，这些组成部分一起展示了抽象的虚拟机的内部体系结构。2.1 class文件Java class文件包含了关于类或接口的所有信息。class文件的“基本类型”如下：u11个字节，无符号类型u22个字节，无符号类型u44个字节，无符号类型u88个字节，无符号类型如果想了解更多，Oracle的JVM SE7给出了官方规范：The Java® Virtual Machine Specificationclass文件包含的内容：ClassFile { u4 magic; //魔数：0xCAFEBABE，用来判断是否是Java class文件 u2 minor_version; //次版本号 u2 major_version; //主版本号 u2 constant_pool_count; //常量池大小 cp_info constant_pool[constant_pool_count-1]; //常量池 u2 access_flags; //类和接口层次的访问标志（通过|运算得到） u2 this_class; //类索引（指向常量池中的类常量） u2 super_class; //父类索引（指向常量池中的类常量） u2 interfaces_count; //接口索引计数器 u2 interfaces[interfaces_count]; //接口索引集合 u2 fields_count; //字段数量计数器 field_info fields[fields_count]; //字段表集合 u2 methods_count; //方法数量计数器 method_info methods[methods_count]; //方法表集合 u2 attributes_count; //属性个数 attribute_info attributes[attributes_count]; //属性表}2.2 类装载器子系统类装载器子系统负责查找并装载类型信息。其实Java虚拟机有两种类装载器：系统装载器和用户自定义装载器。前者是Java虚拟机实现的一部分，后者则是Java程序的一部分。启动类装载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自java.lang.ClassLoader。扩展类装载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。应用程序类装载器（application class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。除了系统提供的类装载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类装载器，以满足一些特殊的需求。类装载器子系统涉及Java虚拟机的其它几个组成部分以及来自java.lang库的类。ClassLoader定义的方法为程序提供了访问类装载器机制的接口。此外，对于每一个被装载的类型，Java虚拟机都会为它创建一个java.lang.Class类的实例来代表该类型。和其它对象一样，用户自定义的类装载器以及Class类的实例放在内存中的堆区，而装载的类型信息则位于方法区。类装载器子系统除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及解析符号引用。这些动作还需要按照以下顺序进行：装载（查找并装载类型的二进制数据）连接（执行验证：确保被导入类型的正确性；准备：为类变量分配内存，并将其初始化为默认值；解析：把类型中的符号引用转换为直接引用）初始化（类变量初始化为正确初始值）2.3 方法区在Java虚拟机中，关于被装载的类型信息存储在一个方法区的内存中。当虚拟机装载某个类型时，它使用类装载器定位相应的class文件，然后读入这个class文件并将它传输到虚拟机中，接着虚拟机提取其中的类型信息，并将这些信息存储到方法区。方法区也可以被垃圾回收器收集，因为虚拟机允许通过用户定义的类装载器来动态扩展Java程序。方法区中存放了以下信息：这个类型的全限定名（如全限定名java.lang.Object）这个类型的直接超类的全限定名这个类型是类类型还是接口类型这个类型的访问修饰符（public, abstract, final的某个子集）任何直接超接口的全限定名的有序列表该类型的常量池（一个有序集合，包括直接常量[string, integer和floating point常量]和对其它类型、字段和方法的符号引用）字段信息（字段名、类型、修饰符）方法信息（方法名、返回类型、参数数量和类型、修饰符）除了常量以外的所有类（静态）变量指向ClassLoader类的引用（每个类型被装载时，虚拟机必须跟踪它是由启动类装载器还是由用户自定义类装载器装载的）指向Class类的引用（对于每一个被装载的类型，虚拟机相应地为它创建一个java.lang.Class类的实例。比如你有一个到java.lang.Integer类的对象的引用，那么只需要调用Integer对象引用的getClass()方法，就可以得到表示java.lang.Integer类的Class对象）2.4 堆Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。需要注意的是，Java虚拟机有一条在堆中分配对象的指令，却没有释放内存的指令，因为虚拟机把这个任务交给垃圾收集器处理。Java虚拟机规范并没有强制规定垃圾收集器，它只要求虚拟机实现必须“以某种方式”管理自己的堆空间。比如某个实现可能只有固定大小的堆空间，当空间填满，它就简单抛出OutOfMemory异常，根本不考虑回收垃圾对象的问题，但却是符合规范的。Java虚拟机规范并没有规定Java对象在堆中如何表示，这给虚拟机的实现者决定怎么设计。一个可能的堆设计如下：一个句柄池，一个对象池。一个对象的引用就是一个指向句柄池的本地指针。这种设计的好处有利于堆碎片的整理，当移动对象池中的对象时，句柄部分只需更改一下指针指向对象的新地址即可。缺点是每次访问对象的实例变量都要经过两次指针传递。2.5 Java栈每当启动给一个线程时，Java虚拟机会为它分配一个Java栈。Java栈由许多栈帧组成，一个栈帧包含一个Java方法调用的状态。当线程调用一个Java方法时，虚拟机压入一个新的栈帧到该线程的Java栈中，当该方法返回时，这个栈帧就从Java栈中弹出。Java栈存储线程中Java方法调用的状态–包括局部变量、参数、返回值以及运算的中间结果等。Java虚拟机没有寄存器，其指令集使用Java栈来存储中间数据。这样设计的原因是为了保持Java虚拟机的指令集尽量紧凑，同时也便于Java虚拟机在只有很少通用寄存器的平台上实现。另外，基于栈的体系结构，也有助于运行时某些虚拟机实现的动态编译器和即时编译器的代码优化。2.5.1 栈帧栈帧由局部变量区、操作数栈和帧数据区组成。当虚拟机调用一个Java方法时，它从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小，并根据此分配栈帧内存，然后压入Java栈中。2.5.1.1 局部变量区局部变量区被组织为以字长为单位、从0开始计数的数组。字节码指令通过从0开始的索引使用其中的数据。类型为int, float, reference和returnAddress的值在数组中占据一项，而类型为byte, short和char的值在存入数组前都被转换为int值，也占据一项。但类型为long和double的值在数组中却占据连续的两项。2.5.1.2 操作数栈和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。它通过标准的栈操作访问–压栈和出栈。由于程序计数器无法被程序指令直接访问，Java虚拟机的指令是从操作数栈中取得操作数，所以它的运行方式是基于栈而不是基于寄存器。虚拟机把操作数栈作为它的工作区，因为大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。2.5.1.3 帧数据区除了局部变量区和操作数栈，Java栈帧还需要帧数据区来支持常量池解析、正常方法返回以及异常派发机制。每当虚拟机要执行某个需要用到常量池数据的指令时，它会通过帧数据区中指向常量池的指针来访问它。除了常量池的解析外，帧数据区还要帮助虚拟机处理Java方法的正常结束或异常中止。如果通过return正常结束，虚拟机必须恢复发起调用的方法的栈帧，包括设置程序计数器指向发起调用方法的下一个指令；如果方法有返回值，虚拟机需要将它压入到发起调用的方法的操作数栈。为了处理Java方法执行期间的异常退出情况，帧数据区还保存一个对此方法异常表的引用。2.6 程序计数器对于一个运行中的Java程序而言，每一个线程都有它的程序计数器。程序计数器也叫PC寄存器。程序计数器既能持有一个本地指针，也能持有一个returnAddress。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。这里的地址可以是一个本地指针，也可以是方法字节码中相对该方法起始指令的偏移量。如果该线程正在执行一个本地方法，那么此时程序计数器的值是“undefined”。2.7 本地方法栈任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的栈，虚拟机只是简单地动态连接并直接调用指定的本地方法。其中方法区和堆由该虚拟机实例中所有线程共享。当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息放到方法区。当程序运行时，虚拟机会把所有该程序在运行时创建的对象放到堆中。像其它运行时内存区一样，本地方法栈占用的内存区可以根据需要动态扩展或收缩。3 执行引擎在Java虚拟机规范中，执行引擎的行为使用指令集定义。实现执行引擎的设计者将决定如何执行字节码，实现可以采取解释、即时编译或直接使用芯片上的指令执行，还可以是它们的混合。执行引擎可以理解成一个抽象的规范、一个具体的实现或一个正在运行的实例。抽象规范使用指令集规定了执行引擎的行为。具体实现可能使用多种不同的技术–包括软件方面、硬件方面或树种技术的结合。作为运行时实例的执行引擎就是一个线程。运行中Java程序的每一个线程都是一个独立的虚拟机执行引擎的实例。从线程生命周期的开始到结束，它要么在执行字节码，要么执行本地方法。3.1 指令集方法的字节码流由Java虚拟机的指令序列构成。每一条指令包含一个单字节的操作码，后面跟随0个或多个操作数。操作码表示需要执行的操作；操作数向Java虚拟机提供执行操作码需要的额外信息。当虚拟机执行一条指令时，可能使用当前常量池中的项、当前帧的局部变量中的值或者位于当前帧操作数栈顶端的值。抽象的执行引擎每次执行一条字节码指令。Java虚拟机中运行的程序的每个线程（执行引擎实例）都执行这个操作。执行引擎取得操作码，如果操作码有操作数，就取得它的操作数。它执行操作码和跟随的操作数规定的动作，然后再取得下一个操作码。这个执行字节码的过程在线程完成前将一直持续，通过从它的初始方法返回，或者没有捕获抛出的异常都可以标志着线程的完成。4 本地方法接口Java本地接口，也叫JNI（Java Native Interface），是为可移植性准备的。本地方法接口允许本地方法完成以下工作：传递或返回数据操作实例变量操作类变量或调用类方法操作数组对堆的对象加锁装载新的类抛出异常捕获本地方法调用Java方法抛出的异常捕获虚拟机抛出的异步异常指示垃圾收集器某个对象不再需要参考：《深入Java虚拟机》 &lt;/div&gt; 文章转自： http://www.jianshu.com/p/9704050f0227 作者：LeoLiang","categories":[],"tags":[]}]}